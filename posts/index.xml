<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Posts on Mango Blog</title><link>https://et860525.github.io/posts/</link><description>Recent content in Posts on Mango Blog</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sun, 26 Feb 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://et860525.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Pnpm ( Performant Node Package Manager )</title><link>https://et860525.github.io/posts/pnpm/</link><pubDate>Sun, 26 Feb 2023 00:00:00 +0000</pubDate><guid>https://et860525.github.io/posts/pnpm/</guid><description>&lt;p>&lt;a href="https://pnpm.io/">Pnpm&lt;/a> ( Performant Node Package Manager ) 是一個套件管理器。根據官網表示，可以節省磁碟空間並提升安裝速度。&lt;/p>
&lt;blockquote>
&lt;p>Fast, disk space efficient package manager&lt;/p>
&lt;/blockquote></description></item><item><title>Rust: 生命週期( Lifetimes )</title><link>https://et860525.github.io/posts/rust-lifetimes/</link><pubDate>Fri, 10 Feb 2023 00:00:00 +0000</pubDate><guid>https://et860525.github.io/posts/rust-lifetimes/</guid><description>&lt;p>&lt;strong>生命週期 ( lifetimes )&lt;/strong> 會確保我們在需要引用的時候，它們都是有效的。&lt;/p>
&lt;p>在 Rust 中，每個引用都是有生命週期的，簡單來說就是它的有效範圍。在大多情況下，生命週期都是隱藏且可以推導出來的，如同型別一樣也都是可以推導出來的。當型別有很多種可能的情況下，就要&lt;strong>詮釋型別&lt;/strong>，同樣在生命週期下，引用以不同方式關聯的話，就要&lt;strong>詮釋生命週期&lt;/strong>。&lt;/p></description></item><item><title>TypeScript: 初始化 Express 專案</title><link>https://et860525.github.io/posts/typescript-express-initialization/</link><pubDate>Sat, 04 Feb 2023 00:00:00 +0000</pubDate><guid>https://et860525.github.io/posts/typescript-express-initialization/</guid><description>&lt;p>這篇文章會紀錄如何在 &lt;a href="https://expressjs.com/">Express&lt;/a> 專案裡設定 &lt;a href="https://www.typescriptlang.org/">TypeScript&lt;/a>。&lt;/p>
&lt;p>先決條件：&lt;/p>
&lt;ul>
&lt;li>安裝 &lt;a href="https://nodejs.org/en/">Node.js&lt;/a> ( LTS ) 在你的開發環境上&lt;/li>
&lt;li>基本的 &lt;code>Node.js&lt;/code> 、 &lt;code>Express&lt;/code> 與 &lt;code>TypeScript&lt;/code> 知識&lt;/li>
&lt;/ul></description></item><item><title>Rust: 特徵( Trait )</title><link>https://et860525.github.io/posts/rust-trait/</link><pubDate>Wed, 01 Feb 2023 00:00:00 +0000</pubDate><guid>https://et860525.github.io/posts/rust-trait/</guid><description>&lt;p>特徵( trait )，是定義特定型別與其他型別共享的功能。可以使用&lt;strong>特徵界限 ( trait bounds )&lt;/strong> 來指定泛型型別為擁有特定行為的任意型別。&lt;/p>
&lt;blockquote>
&lt;p>特徵類似於其他語言常稱作&lt;strong>介面 ( interfaces )&lt;/strong> 的功能，但還是有些差異。&lt;/p>
&lt;/blockquote></description></item><item><title>Rust: 泛型( Generics )</title><link>https://et860525.github.io/posts/rust-generics/</link><pubDate>Tue, 31 Jan 2023 00:00:00 +0000</pubDate><guid>https://et860525.github.io/posts/rust-generics/</guid><description>&lt;p>泛型 ( generics )，實際型別或屬性的抽象表示。舉例來說，&lt;code>String&lt;/code> 和 &lt;code>i32&lt;/code> 這兩個不同型別的資料都可以被存到 &lt;a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Vec 結構體&lt;/a>建立的實例中，不需要針對型別來做分別，只要使用 &lt;code>Vec&amp;lt;String&amp;gt;&lt;/code> 或 &lt;code>Vec&amp;lt;i32&amp;gt;&lt;/code>，這是因為 &lt;code>Vec&lt;/code> 結構體使用了泛型。&lt;/p>
&lt;p>泛型就是 &lt;strong>參數多型 ( parametric polymorphism )&lt;/strong>，在定義型別或函數的時候不去明確指定具體的型別，而是以參數的形式來傳入型別，這可以讓程式設計更為彈性。&lt;/p>
&lt;p>以下先來看泛型在各個地方中如何定義。&lt;/p></description></item><item><title>Rust: 所有權( Ownership )</title><link>https://et860525.github.io/posts/rust-ownership/</link><pubDate>Mon, 30 Jan 2023 00:00:00 +0000</pubDate><guid>https://et860525.github.io/posts/rust-ownership/</guid><description>&lt;p>在一開始撰寫文章時，本來想以寫比較久的 TypeScript 來做部落格的開頭文章，但在過年前接觸到 Rust 這個程式語言，就順勢把最近學到的東西放上來。等到把在 TypeScript 遇到的問題整理一下再寫成一個系列放上來。&lt;/p>
&lt;p>&lt;strong>所有權 ( ownership )&lt;/strong> 是 Rust 用來 &lt;strong>管理程式記憶體的一系列規則&lt;/strong>，讓 Rust 不需要&lt;a href="https://zh.wikipedia.org/zh-tw/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)">垃圾回收 ( Garbage collection )&lt;/a> 就可以保障記憶體的安全。&lt;/p></description></item><item><title>將 Hugo 產生的靜態網站部屬在 GitHub Pages</title><link>https://et860525.github.io/posts/hugo-with-github-pages/</link><pubDate>Wed, 11 Jan 2023 00:00:00 +0000</pubDate><guid>https://et860525.github.io/posts/hugo-with-github-pages/</guid><description>&lt;p>在初期建立部落格時，本來是想租一台虛擬主機，再把寫好的網頁丟上去，不過最後還是選擇使用 &lt;a href="https://pages.github.com/">GitHub Pages&lt;/a>。&lt;/p>
&lt;p>Jekyll 是 Github 建議的靜態網站產生器，不過在查詢資料時發現由 Go 所建構的 &lt;a href="https://gohugo.io/">Hugo&lt;/a>，點進去網頁上面就寫著自己是「世界上最快的網站架設框架」，那不試試看怎麼行。&lt;/p></description></item></channel></rss>