[{"content":"使用 Docker 來建置 MongoDB，可以先到 docker mongo 來選擇版本。\nMongoDB 會有幾種架構：\nStandalone 建立難度 低 單一 MongoDB 資料庫 Replica Set 建立難度 中 資料會有多個副本提供容錯空間 Sharded Cluster 建立難度 高 資料放置在不同的 shard，每個 shard 或 config servers 都是 Replica Set Standalone Standalone 表示只有一個 MongoDB 實體，Mongo Client 只要直接連接它就可以使用。\n根據 Docker compose file 所顯示，2023年六月後就不會支援 Compose V1 ，所以除了在 Standalone 會試做一個 V1，其他都會換成 Compose V2 的格式\nDocker compose V1 使用 docker-compose 來建立 MongoDB：\n# docker-compose.yml versio: \u0026#39;3.1\u0026#39; services: mongo: image: mongo:latest container_name: mongodb environment: MONGO_INITDB_ROOT_USERNAME: root MONGO_INITDB_ROOT_PASSWORD: example ports: - \u0026#39;27017:27017\u0026#39; volumes: - mongo-mount-data:/data/db 運行 docker-compose：\n# Start docker-compose up -d # Close docker-compose down Docker compose V2 # docker-compose.yaml services: mongo: image: mongo:latest container_name: mongodb-test environment: MONGO_INITDB_ROOT_USERNAME: root MONGO_INITDB_ROOT_PASSWORD: example ports: - \u0026#39;27017:27017\u0026#39; volumes: - mongo-mount-data:/data/db 運行 docker compose：\n# Start docker compose up -d # Close docker compose down 進入 mongoDB docker exec -it \u0026lt;mongo-name\u0026gt; bash 輸入後會看到命令列會由 root 開頭，接著再輸入：\n# 5.0+ mongosh -u root -p # 4.0 mongo -u root -p 輸入密碼後，就可以進入 MongoDB 了。\n使用 VM 會遇到的問題 如果在 VM 下使用 MongoDB 5.0+ 以上的版本，有可能會看到：\nWARNING: MongoDB 5.0+ requires a CPU with AVX support, and your current system does not appear to have that! 根據 Mongo DB deployment not working in kubernetes because processor doesn\u0026rsquo;t have AVX support\n如果是 Windows + VirtualBox 可以在 CMD 輸入：\nbcdedit /set hypervisorlaunchtype off DISM /Online /Disable-Feature:Microsoft-Hyper-V 重開機後就可以解決。\n目前我這裡還是有使用 WSL2，如果輸入以上指令可能會造成 WSL2 無法使用，所以我選擇使用舊版本，暫且不使用 mongo:5.0+。\nReplica Set MongoDB Replication 可以建立一份資料庫副本，在主要的資料庫發生問題時，副本可以直接接手主要資料庫的工作。\n使用 Replica Set 的重點：\nReplica Set 會提供 High availability 依照硬體規格來調整 Replica Set，例如：更大更快的硬碟 不會影響 Primary，使用 Read Preference 來讀取更快更近的副本 MongoDB Replication 的架構 MongoDB Replication 主要的架構的構成：\nReplica Set Member 有兩種：\nPrimary：接受所有讀寫的操作 Secondaries：複製 Primary 的資料 最基本的 Replica Set 需要有三個數據承載成員 ( data-bearing members )：一個 Primary 與二個 Secondary：\n在某些情況下 ( 例如：硬體限制 ) 可以將某個 member 改為 arbiter，它只會參與 投票 ( elections ) 並不會擁有任何資料，更不會成為 Primary：\n以下使用 Docker compose 來建構 Replica Set。\nDocker compose 使用 Docker compose 來建立下方的架構：\n這一個 Replica Set 命名為 RS，需要使用 --replSet RS 建立三個 container 來滿足最基本的 Replica Set： container (rs1/rs2/rs3) ；port ( 27041/27042/27043) docker-compose-replica-set.yaml：\nservices: rs1: image: mongo:4.4.19-focal container_name: rs1 network_mode: host command: mongod --replSet RS --port 27041 --dbpath /data/db --config /resource/mongod.yaml volumes: - ./replica/config/mongod.yaml:/resource/mongod.yaml - ./replica/data/rs1:/data/db extra_hosts: - \u0026#34;rs1.local:127.0.0.1\u0026#34; - \u0026#34;rs2.local:127.0.0.1\u0026#34; - \u0026#34;rs3.local:127.0.0.1\u0026#34; rs2: image: mongo:4.4.19-focal container_name: rs2 network_mode: host command: mongod --replSet RS --port 27042 --dbpath /data/db --config /resource/mongod.yaml volumes: - ./replica/config/mongod.yaml:/resource/mongod.yaml - ./replica/data/rs2:/data/db extra_hosts: - \u0026#34;rs1.local:127.0.0.1\u0026#34; - \u0026#34;rs2.local:127.0.0.1\u0026#34; - \u0026#34;rs3.local:127.0.0.1\u0026#34; rs3: image: mongo:4.4.19-focal container_name: rs3 network_mode: host command: mongod --replSet RS --port 27043 --dbpath /data/db --config /resource/mongod.yaml volumes: - ./replica/config/mongod.yaml:/resource/mongod.yaml - ./replica/data/rs3:/data/db extra_hosts: - \u0026#34;rs1.local:127.0.0.1\u0026#34; - \u0026#34;rs2.local:127.0.0.1\u0026#34; - \u0026#34;rs3.local:127.0.0.1\u0026#34; network_mode 設定為 host，資料庫會如同架設在本機一樣，讓 rs1.local、rs2.local 與 rs3.local 都會對應到 127.0.0.1 command 裡面的設定： --dbpath：指定 MongoDB 存放資料的資料夾 --port：指定 MongoDB 要開啟的 Port --config：指定 MongoDB Config file volumes 裡面的設定： ./replica/config/mongod.yaml:/resource/mongod.yaml：其格式為 A:B，A 為主機端的路徑；B 為容器內的路徑。當容器掛載完成，容器端就會有 /resource/mongod.yaml 檔案，達到路徑能共享資料的功能 ./replica/data/rs3:/data/db：與上方設定很像，資料共享與綁定。當目前的容器被刪除後，其資料都會被存放在本機端，等待下一個容器指向相同的位置，就可以繼續使用以前的資料 extra_hosts 設定解析的域名 rs1.local、rs2.local 與 rs3.local 都會解析 127.0.0.1，這樣就不用再打 127.0.0.1 接下來設定 MongoDB config file replica/config/mongod.yaml：\nnet: bindIpAll: true storage: engine: wiredTiger wiredTiger: engineConfig: cacheSizeGB: 0.1 net Option 裡的 bindIpAll：設定那些 Client IP 可以連進 MongoDB，預設為 localhost 也就是只有本機。假設 Client IP 來自不同的主機，設定 true 就表示任何 Client IP 都可以連進來 storage Option 裡的 engine：有 wiredTiger 與 inMemory 兩種，不論選擇哪一個都要小心設定 cacheSizeGB 或 inMemorySizeGB 的大小。這是因為 Mongo 會依照硬體配置來計算內部緩存的預設值，而 Mongo 並不會知道自己運行在 Docker 容器中，所以在同一個 Docker 上架設兩台以上的 Mongo，就有可能會出現問題，如：斷線或無法連線進去。所以使用 Docker 架設 Mongo 一定要設定 以上只用使用幾個重要的設定，完整的 Mongo config 可以到 Configuration File Options。\n都完成後，使用 docker compose up -d 來運行。\nReplica Set 設定 確認資料庫連線狀況 進入 rs1 容器，來測試能否用域名連線到其他資料庫：\ndocker exec -it rs1 bash 確認資料庫連線：\nmongo rs1.local:27041 --eval \u0026#34;print(\u0026#39;rs1 ok\u0026#39;)\u0026#34; mongo rs2.local:27042 --eval \u0026#34;print(\u0026#39;rs2 ok\u0026#39;)\u0026#34; mongo rs3.local:27043 --eval \u0026#34;print(\u0026#39;rs3 ok\u0026#39;)\u0026#34; 如果都能顯示這些字串，就可以開始設定 Replica Set。\n設定 Replica Set 隨便進入一個 member：\nmongo rs1.local:27041 設定 Replica Set config：\ncfg = { \u0026#34;_id\u0026#34;: \u0026#34;RS\u0026#34;, \u0026#34;members\u0026#34;: [{ \u0026#34;_id\u0026#34;: 0, \u0026#34;host\u0026#34;: \u0026#34;rs1.local:27041\u0026#34; }, { \u0026#34;_id\u0026#34;: 1, \u0026#34;host\u0026#34;: \u0026#34;rs2.local:27042\u0026#34; }, { \u0026#34;_id\u0026#34;: 2, \u0026#34;host\u0026#34;: \u0026#34;rs3.local:27043\u0026#34; } ] }; rs.initiate(cfg); 顯示 ok: 1 就表示完成。\n確認 Replica Set 狀態 當要增加或減少 member 時，或是要檢查 member 是否有連線，就要確認 member 的狀態。最常用的有三種：\nrs.status()：members 的狀態 rs.status().members.forEach(m =\u0026gt; print(`${m.name} =\u0026gt; ${m.stateStr}`)) 會列出： rs1.local:27041 =\u0026gt; PRIMARY rs2.local:27042 =\u0026gt; SECONDARY rs3.local:27043 =\u0026gt; SECONDARY 當然也可以直接使用 rs.status() 來看更詳細的狀態。 rs.printSecondaryReplicationInfo()：members 的同步狀態 source: rs2.local:27042 syncedTo: Fri Mar 03 2023 11:50:04 GMT+0000 (UTC) 0 secs (0 hrs) behind the primary source: rs3.local:27043 syncedTo: Fri Mar 03 2023 11:50:04 GMT+0000 (UTC) 0 secs (0 hrs) behind the primary rs.printReplicationInfo()：members 的 oplog 狀態 configured oplog size: 6040.000781059265MB log length start to end: 18735secs (5.2hrs) oplog first event time: Fri Mar 03 2023 06:33:09 GMT+0000 (UTC) oplog last event time: Fri Mar 03 2023 11:45:24 GMT+0000 (UTC) now: Fri Mar 03 2023 11:45:31 GMT+0000 (UTC) 結語 起初會接觸到 Replica Set 的原因，是出自於我想使用 Prisma 連接 local MongoDB。不過當連接時就會跳出錯誤：\nprisma needs to perform transactions, which requires your mongodb server to be run as a replica set. 這也讓我想了解一下這個 Replica Set 到底是什麼東西。\n而看了該文章才知道，在 Docker 裡建立 MongoDB 時需要設定 cacheSizeGB 來設定緩存大小。可能是通常我也只會使用到一個的 MongoDB 資料庫，所以才沒有遇到那些問題。\nReference [資料庫]使用 Docker 構築不同 MongoDB 架構 (三) - Replica Set ","permalink":"https://et860525.github.io/posts/docker-mongodb/","summary":"\u003cp\u003e使用 Docker 來建置 MongoDB，可以先到 \u003ca href=\"https://hub.docker.com/_/mongo\"\u003edocker mongo\u003c/a\u003e 來選擇版本。\u003c/p\u003e\n\u003cp\u003eMongoDB 會有幾種架構：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eStandalone\n\u003cul\u003e\n\u003cli\u003e建立難度 \u003cstrong\u003e低\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e單一 MongoDB 資料庫\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.mongodb.com/docs/manual/replication/\"\u003eReplica Set\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e建立難度 \u003cstrong\u003e中\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e資料會有多個副本提供容錯空間\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.mongodb.com/docs/manual/sharding/\"\u003eSharded Cluster\u003c/a\u003e\n\u003cul\u003e\n\u003cli\u003e建立難度 \u003cstrong\u003e高\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e資料放置在不同的 shard，每個 shard 或 config servers 都是 \u003ccode\u003eReplica Set\u003c/code\u003e\n\u003cimg loading=\"lazy\" src=\"/images/Docker-mongodb/Docker-sharded-cluster-production-architecture.png\" alt=\"Docker-sharded-cluster-production-architecture.png\"  /\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ol\u003e","title":"Docker: 設定 MongoDB"},{"content":"Pnpm ( Performant Node Package Manager ) 是一個套件管理器。根據官網表示，可以節省磁碟空間並提升安裝速度。\nFast, disk space efficient package manager\npnpm 的特點 不同的專案共用依賴套件，節省磁碟空間 所有依賴套件的檔案都會被存在同一個位置中，當有專案需要依賴套件時，它的檔案會被硬連結到該位置，這樣就不會消耗額外的磁碟空間\n非扁平化的 node_modules 目錄 npm 與 yarn 都是以扁平化的方式建立 node_modules 目錄，他們會產生非法訪問依賴的問題。舉個例子，今天有 A、B 和 C 三種套件，而他們之中的關係是 A 依賴 C 的 API，如果 B 版本更新並依賴 C 的 2.0.1 版本，但 A 依然還是使用舊版的 C，那就會報錯。\n而 pnpm 是使用軟連結的方式來建構 node_modules 目錄：\n當開發者安裝套件 bar@1.0.0，而 bar@1.0.0 又依賴 foo@1.0.0套件，此時 pnpm 就會將專案直接依賴的套件硬連結於 .pnpm store。而 bar@1.0.0 的 foo@1.0.0 就會使用軟連結直接依賴的 foo@1.0.0。\n這樣就可以避免非法訪問依賴的問題了。\n更多與 npm/yarn 的比較 Feature Comparison\n安裝方式 我使用的是 Linux 系統，根據官網的文件下載：\n# bash wget -qO- https://get.pnpm.io/install.sh | ENV=\u0026#34;$HOME/.bashrc\u0026#34; SHELL=\u0026#34;$(which bash)\u0026#34; bash - 其他下載方式：pnpm Installation\nCommands npm command pnpm equivalent npm init pnpm init npm install pnpm install npm i \u0026lt;pkg\u0026gt; pnpm add \u0026lt;pkg\u0026gt; npm run \u0026lt;cmd\u0026gt; pnpm \u0026lt;cmd\u0026gt; pnpm update：如果沒有加上 --filter 來指定 package，那就是更新全部 pnpm remove：也可以使用 rm, uninstall, un 更多的指令可以參考官網的 CLI commands。\n結論 最近開始轉成使用 pnpm，有感的就是速度很快。會使用它最大的原因就是它能將依賴件都放在同一資料夾管理 (專案裡的.pnpm)，這樣就不會因為不同的依賴件版本，造成其他依賴件錯誤的問題。\nSource pnpm, Fast, disk space efficient package manager 为什么现在我更推荐 pnpm 而不是 npm/yarn? ","permalink":"https://et860525.github.io/posts/pnpm/","summary":"\u003cp\u003e\u003ca href=\"https://pnpm.io/\"\u003ePnpm\u003c/a\u003e ( Performant Node Package Manager ) 是一個套件管理器。根據官網表示，可以節省磁碟空間並提升安裝速度。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eFast, disk space efficient package manager\u003c/p\u003e\n\u003c/blockquote\u003e","title":"Pnpm ( Performant Node Package Manager )"},{"content":"生命週期 ( lifetimes ) 會確保我們在需要引用的時候，它們都是有效的。\n在 Rust 中，每個引用都是有生命週期的，簡單來說就是它的有效範圍。在大多情況下，生命週期都是隱藏且可以推導出來的，如同型別一樣也都是可以推導出來的。當型別有很多種可能的情況下，就要詮釋型別，同樣在生命週期下，引用以不同方式關聯的話，就要詮釋生命週期。\n透過生命週期預防迷途引用 生命週期最主要的目的就是要預防迷途引用 ( dangling references )：\nfn main() { let r; { let x = 5; r = \u0026amp;x; } println!(\u0026#34;r: {}\u0026#34;, r); } 在這裡嘗試使用已經離開作用域的引用，就會得到錯誤訊息，這是因為 r 所指向的數值已經離開作用域。這也表示變數 x 存在的不夠久。那 Rust 要如何決定程式碼無效？它使用了借用檢查器 ( borrow checker ) 來做檢查。\n借用檢查器 ( Borrow checker ) Rust 編譯器有一個借用檢查器 ( borrow checker ) 會比較作用域來檢測所有的借用是否有效。\n依上面的程式碼為例：\nfn main() { let r; // ---------+-- \u0026#39;a // | { // | let x = 5; // -+-- \u0026#39;b | r = \u0026amp;x; // | | } // -+ | // | println!(\u0026#34;r: {}\u0026#34;, r); // | } // ---------+ r 的生命週期為 'a，x 為 'b，可以看到 'b 的生命週期區塊比 'a 還要小。而 r 引用了一個生命週期比他自己還短的變數 x，所以程式會報錯：引用的對象比引用者存在的時間還短。\n以下為修正版本：\nfn main() { let x = 5; // ----------+-- \u0026#39;b // | let r = \u0026amp;x; // --+-- \u0026#39;a | // | | println!(\u0026#34;r: {}\u0026#34;, r); // | | // --+ | } // ----------+ 此時 x 的生命週期 'b 比 r 的生命週期 'a 還長，Rust 就能知道 r 引用 x 是永遠有效的。\n函式中的泛型生命週期 寫一個比較兩個字串切片誰比較長的函式。該函式會接收兩個字串切片並回傳一個字串切片：\nfn main() { let string1 = String::from(\u0026#34;abcd\u0026#34;); let string2 = \u0026#34;xyz\u0026#34;; let result = longest(string1.as_str(), string2); println!(\u0026#34;The longest string is {}\u0026#34;, result); } 該函式接收的是字串切片的引用，而不是字串，因此我們不希望 longest 拿到參數的所有權。\n字串切片本來就是引用，所以作為參數時可以不用加入 \u0026amp;\n實作 longest 函式：\nfn longest(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;str { if x.len() \u0026gt; y.len() { x } else { y } } 編譯後會出現生命週期的錯誤：\n$ cargo run Compiling chapter10 v0.1.0 (file:///projects/hello) error[E0106]: missing lifetime specifier --\u0026gt; src/main.rs:9:33 | 9 | fn longest(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;str { | ---- ---- ^ expected named lifetime parameter | = help: this function\u0026#39;s return type contains a borrowed value, but the signature does not say whether it is borrowed from `x` or `y` help: consider introducing a named lifetime parameter | 9 | fn longest\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;a str, y: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str { | ++++ ++ ++ ++ For more information about this error, try `rustc --explain E0106`. error: could not compile `chapter10` due to previous error 錯誤訊息表示回傳型別必須要有一個泛型生命週期參數，因為 Rust 不知道回傳的引用是 x 還是 y。事實上我們也不知道，因為這裡是交由 if else 區塊判定 x 和 y 哪個字串大就回傳哪個。\n當我們不知道哪個字串會被回傳，也不知道傳遞進來的引用實際的生命週期為何，就會造成以上的問題。為了解決這個錯誤，必須要加上泛型生命週期參數來定義引用的關係，讓借用檢查器能夠分析。\n生命週期詮釋語法 生命週期詮釋 ( Lifetime Annotation ) 不會改變引用能存活多久，只是描述引用之間的相互關係，不會影響引用的生命週期。這就像函式簽名指定了一個泛型型別參數，該函式就能接受任意型別一樣。函式可以指定一個泛型生命週期參數，該函式就能接受任何生命週期。\n生命週期參數的名稱必須以 ( ' ) 作為開頭，通常是小寫且很短。大多數人都使用 'a 作為第一個生命週期詮釋。將生命週期詮釋放在 \u0026amp; 後面，再使用空格來詮釋引用的型別：\n\u0026amp;i32 // 一個引用 \u0026amp;\u0026#39;a i32 // 一個有顯式生命週期的引用 \u0026amp;\u0026#39;a mut i32 // 一個有顯式生命週期的可變引用 在函式簽名中的生命週期詮釋 在此段簽名想要表達：當所有傳遞進來的參數都是有效的，那回傳的引用才會是有效的。以下會將生命週期命名為 'a 並加進每個引用：\nfn longest\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;a str, y: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str { if x.len() \u0026gt; y.len() { x } else { y } } 這樣更改完 longest 就能執行了。\n此函式簽名告訴 Rust 有個生命週期 'a，函式的兩個參數都是字串切片，並且都有生命週期 'a，而回傳的字串切片也會和生命週期 'a 存活一樣久。\n注意：當此函式簽名指定生命週期參數時，就不能變更任何傳入或傳出數值的生命週期。這個目的只是為了告訴借用檢查器一件事，拒絕任何沒有服從約束的數值。longest 函式並不需要知道 x 與 y 會存活多久，它只需要知道有某個作用域會被 'a 所取代。\n當 longest 傳入實際的引用時，泛型生命週期 'a 取得的生命週期，會等於 x 與 y 的生命週期中較短的，而回傳引用的生命週期也會相同。\n傳入不同實際生命週期的引用，來使生命週期詮釋能約束 longest 函式：\nfn main() { let string1 = String::from(\u0026#34;Long long string\u0026#34;); { let string2 = String::from(\u0026#34;xyz\u0026#34;); let result = longest(string1.as_str(), string2.as_str()); println!(\u0026#34;The longest string is {}\u0026#34;, result); } } string1 在外部作用域結束前都有效；string2 在內部作用域結束前都有效。 result 會取得某個引用直到內部作用域結束 ( 依照參數最短的生命週期 )。 接下來做一點改變，如果將 result 移動到外部作用域做宣告，並保留 result 的賦值與 string2 在內部作用域。並將使用 result 的 println! 移動到外部作用域，編譯並且觀看結果：\nfn main() { let string1 = String::from(\u0026#34;Long long string\u0026#34;); let result; { let string2 = String::from(\u0026#34;xyz\u0026#34;); result = longest(string1.as_str(), string2.as_str()); } println!(\u0026#34;The longest string is {}\u0026#34;, result); } 編譯後會看到以下的錯誤訊息：\n$ cargo run Compiling chapter10 v0.1.0 (file:///projects/hello) error[E0597]: `string2` does not live long enough --\u0026gt; src/main.rs:6:44 | 6 | result = longest(string1.as_str(), string2.as_str()); | ^^^^^^^^^^^^^^^^ borrowed value does not live long enough 7 | } | - `string2` dropped here while still borrowed 8 | println!(\u0026#34;The longest string is {}\u0026#34;, result); | ------ borrow later used here For more information about this error, try `rustc --explain E0597`. error: could not compile `chapter10` due to previous error 錯誤訊息表示，需要讓 result 與 println! 有效的話，string2 必須要在外部作用域有效，因為 Rust 知道這個函式的參數與回傳值，都使用著相同的生命週期 'a。\n當然我們都知道 string1 字串長度比較長，result 的結果會是 string1 的引用，而且 string1 還在作用域裡，照理來說應該是不會有問題才對。但是編譯器不懂，所以我們才會告訴 Rust 此函式所回傳引用的生命週期，會等於較短的生命週期。所以編譯器才會報錯，因為回傳可能會包含無效的引用。\n深入理解生命週期 再來做一點改變，如果現在 longest 回傳的條件是永遠回傳第一個字串切片，那參數 y 就可以不需要指定生命週期：\nfn longest\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;a str, y: \u0026amp;str) -\u0026gt; \u0026amp;\u0026#39;a str { x } 這是因為 x 與回傳型別的生命週期都是 'a，但現在永遠只回傳 x，y 有沒有生命週期根本沒有任何差別。這也表示當函式回傳引用時，回傳型別的生命週期必須符合其中一個參數的生命週期。所以下面的程式碼是不會編譯成功的：\nfn longest\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;\u0026#39;a str { let result = String::from(\u0026#34;Long long string\u0026#34;); result.as_str() } 因為回傳值的生命週期與參數的生命週期無關。錯誤訊息為：\n$ cargo run Compiling chapter10 v0.1.0 (file:///projects/hello) error[E0515]: cannot return reference to local variable `result` --\u0026gt; src/main.rs:11:5 | 11 | result.as_str() | ^^^^^^^^^^^^^^^ returns a reference to data owned by the current function For more information about this error, try `rustc --explain E0515`. error: could not compile `chapter10` due to previous error 此時我們嘗試從函式中回傳 result 引用， 但 result 已經離開作用域，已經是迷途引用了，Rust 是不會允許使用迷途引用。解決這個問題最好的方法就是回傳有所有權的型別，而不是引用。\n由上可知，生命週期語法是用來連接函式中不同參數與回傳值的生命週期。只要能連結，Rust 就能有足夠的資訊防止產生迷途指標或違反記憶體安全的操作。\n在結構體中使用生命週期詮釋 結構體的所有定義都持有型別的所有權，然而結構體也可以持有引用。在這裡使用 ImportantExcerpt 來當作例子：\nstruct ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt; { part: \u0026amp;\u0026#39;a str, } fn main() { let novel = String::from(\u0026#34;Call me Ishmael. Some years ago...\u0026#34;); let first_sentence = novel.split(\u0026#39;.\u0026#39;).next().expect(\u0026#34;Can not find \u0026#39;.\u0026#39;\u0026#34;); let i = ImportantExcerpt { part: first_sentence, }; } 如同泛型資料型別，在結構體名稱後加上泛型生命週期參數 ( \u0026lt;'a\u0026gt; ) 在 main 裡產生一個結構體 ImportantExcerpt 實例，變數 novel 擁有 String 資料，而 novel 在 ImportantExcerpt 實例之前建立的，這表示 novel 不會比 ImportantExcerpt 早離開作用域，所以 ImportantExcerpt 裡的引用就能成立 省略生命週期 現在我們已經知道每個引用都有生命週期，那是否每一次都要寫出來呢？以下的函式是沒有詮釋生命週期還可以編譯成功的：\nfn first_word(s: \u0026amp;str) -\u0026gt; \u0026amp;str { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return \u0026amp;s[0..i]; } } \u0026amp;s[..] } 以上的程式曾經出現在Rust: 所有權 ( Ownership )，那為什麼它可以不用寫出生命週期？\n如果是在早期版本 Rust ( 1.0 之前 )，上面的程式碼就真的無法編譯了，因為那個時候每個引用都必須要顯示生命週期，在當時此函式就會是：\nfn first_word\u0026lt;\u0026#39;a\u0026gt;(s: \u0026amp;\u0026#39;a str) -\u0026gt; \u0026amp;\u0026#39;a str{ 在寫了大量 Rust 程式碼後，Rust 團隊發現開發者會在特定情況反覆輸入同樣的生命週期詮釋，而這些情況都是可預期的，並且遵循一些明確的模式。所以 Rust 團隊將這些模式加入編譯器的程式碼中，讓借用檢查器可以依據這些規則自行推導生命生命週期。\n這個讓 Rust 分析的模式稱為生命週期省略規則 ( lifetime elision rules ) ，當你的程式碼符合該情形時，就可以不用寫出生命週期。\n生命週期省略規則並不是完美的，還是有一些模稜兩可的生命週期，當編譯器無法猜出生命週期時，就會回傳錯誤給你，說明你必須自己指定生命週期\n生命週期省略規則 ( Lifetime elision rules ) 首先要先知道生命週期有兩種：\n在函式或方法參數上的生命週期稱為輸入生命週期 ( input lifetimes ) 在回傳值的生命週期則稱為輸出生命週期 ( output lifetimes ) 編譯器會根據三項規則來推導沒有顯式生命週期的型別。第一個規則適用於輸入生命週期，而第二與第三個規則適用於輸出生命週期。如果三個規則跑完，還是沒有推斷出生命週期，編譯器就會停止並回傳錯誤。\n第一個規則：編譯器會給予每個引用參數一個生命週期參數：\nfn foo\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;a i32) // 1個參數；1個生命週期 fn foo\u0026lt;\u0026#39;a, \u0026#39;b\u0026gt;(x: \u0026amp;\u0026#39;a i32, y: \u0026amp;\u0026#39;b i32) // 2個參數；2個生命週期 第二個規則：如果只有一個輸入生命週期參數，所有輸出生命週期參數就等於此參數：\nfn foo\u0026lt;\u0026#39;a\u0026gt;(x: \u0026amp;\u0026#39;a i32) -\u0026gt; \u0026amp;\u0026#39;a i32 第三個規則：如果輸入的生命週期參數裡有 \u0026amp;self 或 \u0026amp;mut self，很明顯這就是方法 ( methods )，那 self 的生命週期參數就等同於所有輸出生命週期參數。\n現在就可以根據上面的三個規則，來解釋 函式中的泛型生命週期 裡的 longest 函式錯誤的原因了：\nfn longest(x: \u0026amp;str, y: \u0026amp;str) -\u0026gt; \u0026amp;str { 先套用第一個規則，每個參數都有自己的生命週期。而這次有兩個參數：\nfn longest\u0026lt;\u0026#39;a, \u0026#39;b\u0026gt;(x: \u0026amp;\u0026#39;a str, y: \u0026amp;\u0026#39;b str) -\u0026gt; \u0026amp;str { 第二個規則就不適用了，因為這裡不只有一個生命週期參數。第三個規則也不適用，longest 是函式而不是方法。經過三個規則後，編譯器還是無法推斷出型別的生命週期，這也就是程式會出現錯誤的原因。\n屬於方法定義中的生命週期詮釋 那為什麼第三個規則只適用於方法呢？\n結構體欄位的生命週期永遠需要宣告在 impl 關鍵字後方以及結構體名稱後方，因為這些生命週期是結構體型別的一部分。\n在 impl 區塊中，方法所簽名的引用很可能會與結構體欄位的引用生命週期綁定，當然它們也可能是獨立的。\n這裡使用 ImportantExcerpt 來作範例，首先使用一個方法名為 level，其參數就只有 \u0026amp;self 的引用，而回傳值是 i32 並不是引用：\nstruct ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt; { part: \u0026amp;\u0026#39;a str, } impl\u0026lt;\u0026#39;a\u0026gt; ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt; { fn level(\u0026amp;self) -\u0026gt; i32 { 3 } } 以下為第三個生命週期省略規則適用的範例：\nimpl\u0026lt;\u0026#39;a\u0026gt; ImportantExcerpt\u0026lt;\u0026#39;a\u0026gt; { fn announce_and_return_part(\u0026amp;self, announcement: \u0026amp;str) -\u0026gt; \u0026amp;str { println!(\u0026#34;Notice：{}\u0026#34;, announcement); self.part } } 首先，根據第一個生命週期省略規則，給予 \u0026amp;self 與 announcement 各自的生命週期。然後因為其中一個參數是 \u0026amp;self，適用於第三個生命週期省略規則，所以該回傳型別會取得 \u0026amp;self 的生命週期。\n靜態生命週期 有個特殊的生命週期 'static，這表示該引用可以存活在整個程式期間。字串有 'static 生命週期：\nlet s: \u0026amp;\u0026#39;static str = \u0026#34;I have static lifetime\u0026#34;; 此字串的文字會直接儲存在程式的執行檔中，永遠有效。\n泛型型別參數、特徵界限與生命週期的組合 這邊使用一個函式來組合泛型型別參數、特徵界限與生命週期：\nuse std::fmt::Display; fn longest_with_an_announcement\u0026lt;\u0026#39;a, T\u0026gt;( x: \u0026amp;\u0026#39;a str, y: \u0026amp;\u0026#39;a str, ann: T, ) -\u0026gt; \u0026amp;\u0026#39;a str where T: Display, { println!(\u0026#34;Announcement！{}\u0026#34;, ann); if x.len() \u0026gt; y.len() { x } else { y } } 這個函式會比較兩個字串切片，並回傳比較長的那一個 ann 使用泛型型別 T，後面的 where 可以指定 T 有 Display 特徵。這表示這個 ann 參數可以使用 {} 方式印出來 生命週期也是一種泛型，所以生命週期參數 'a 與 泛型型別參數 T 都會一起寫在 \u0026lt;\u0026gt; 裡 結論 生命週期與所有權都是 Rust 管理記憶體很重要的機制，而透過借用檢查器將引用的作用域做比較，可以讓無效的引用在編譯期間就被發現。在三個生命週期省略規則下，Rust 大多的生命週期都可以自動被推導出來，這就跟這就跟型別一樣。\n以上這些分析都是在編譯期間進行的，完全不會影響執行的效能😆！\n","permalink":"https://et860525.github.io/posts/rust-lifetimes/","summary":"\u003cp\u003e\u003cstrong\u003e生命週期 ( lifetimes )\u003c/strong\u003e 會確保我們在需要引用的時候，它們都是有效的。\u003c/p\u003e\n\u003cp\u003e在 Rust 中，每個引用都是有生命週期的，簡單來說就是它的有效範圍。在大多情況下，生命週期都是隱藏且可以推導出來的，如同型別一樣也都是可以推導出來的。當型別有很多種可能的情況下，就要\u003cstrong\u003e詮釋型別\u003c/strong\u003e，同樣在生命週期下，引用以不同方式關聯的話，就要\u003cstrong\u003e詮釋生命週期\u003c/strong\u003e。\u003c/p\u003e","title":"Rust: 生命週期( Lifetimes )"},{"content":"這篇文章會紀錄如何在 Express 專案裡設定 TypeScript。\n先決條件：\n安裝 Node.js ( LTS ) 在你的開發環境上 基本的 Node.js 、 Express 與 TypeScript 知識 專案初始化 建立一個空的資料夾，並初始化 package.json：\nmkdir express-typescript cd express-typescript npm init -y 下載 Express 與開發伺服器的相關套件：\nnpm i express dotenv dotenv 是一個管理環境變數的套件，可以根據環境的不同設定不同的配置 安裝 TypeScript 與 @types 宣告套件：\nnpm i -D typescript @types/express @types/node @types/\u0026lt;package-name\u0026gt;：只要該套件有支援 TypeScript，你就能在直接使用這個方式，下載預先定義好的宣告檔案 -D 是 --save-dev：表示套件只會存在於 devDependencies 都完成後可以檢查 package.json 檔案 (沒有特殊需求，套件的版本以自己的為準)：\n{ \u0026#34;name\u0026#34;: \u0026#34;express-typescript\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;dotenv\u0026#34;: \u0026#34;^16.0.3\u0026#34;, \u0026#34;express\u0026#34;: \u0026#34;^4.18.2\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;@types/express\u0026#34;: \u0026#34;^4.17.17\u0026#34;, \u0026#34;@types/node\u0026#34;: \u0026#34;^18.11.18\u0026#34;, \u0026#34;typescript\u0026#34;: \u0026#34;^4.9.5\u0026#34; } } 產生 TypeScript 的配置文件 使用以下指令來產生 tsconfig.json：\nnpx tsc --init 在輸出可以看到產生的檔案與預設的設定：\nCreated a new tsconfig.json with: target: es2016 module: commonjs strict: true esModuleInterop: true skipLibCheck: true forceConsistentCasingInFileNames: true You can learn more at https://aka.ms/tsconfig 這裡也可以打開 tsconfig.json 來修改自己需要的設定。以下是我的設定：\n{ \u0026#34;compilerOptions\u0026#34;: { \u0026#34;target\u0026#34;: \u0026#34;es2017\u0026#34;, \u0026#34;module\u0026#34;: \u0026#34;commonjs\u0026#34;, \u0026#34;esModuleInterop\u0026#34;: true, \u0026#34;skipLibCheck\u0026#34;: true, \u0026#34;forceConsistentCasingInFileNames\u0026#34;: true, \u0026#34;strict\u0026#34;: true, \u0026#34;rootDir\u0026#34;: \u0026#34;./src\u0026#34;, \u0026#34;outDir\u0026#34;: \u0026#34;./dist\u0026#34;, }, \u0026#34;include\u0026#34;: [\u0026#34;src/**/*.ts\u0026#34;], \u0026#34;exclude\u0026#34;: [\u0026#34;node_modules\u0026#34;, \u0026#34;dist\u0026#34;] } 預設的設定：\ntarget：指定編譯器所產生的 JavaScript version module：編譯 JavaScript 程式碼使用的 modules manager。commonjs 為 Node.js 的標準 strict：嚴格類型檢查選項 esModuleInterop：讓我們能將 ES6 modules 編譯成 commonJS modules skipLibCheck：如果為 true，則會跳過檢查基礎宣告檔案 ( declaration files ) forceConsistentCasingInFileNames：如果為 true，啟用區分大小寫命名文件 新增的設定：\nrootDir：欲編譯的路徑，把該資料夾裡面的 .ts 都編譯成 JavaScript outDir：編譯後輸出檔案的地方 include：納入編譯的範圍 exclude：不納入編譯的範圍 建立 Express app 首先，先在根目錄 ( root ) 下建立一個檔案 .env，這個檔案存放的是敏感資料供 dotenv 來讀取的。該檔案目前會有以下設定：\nPORT=3000 之後再新增檔案 src/app.ts 並輸入下面的程式碼來建立一個伺服器：\nimport express, { Express, Request, Response } from \u0026#39;express\u0026#39;; import dotenv from \u0026#39;dotenv\u0026#39;; dotenv.config(); const app: Express = express(); const port = process.env.PORT; app.get(\u0026#39;/\u0026#39;, (req: Request, res: Response) =\u0026gt; { res.send(\u0026#39;Express + TypeScript Server\u0026#39;); }); app.listen(port, () =\u0026gt; { console.log( `[server]: Server is running at http://localhost:${port}` ); }); 透過 dotenv 就可以讓 port 獲取在 .env 檔案裡的設定 要運行伺服器前必須要先知道一件事情，瀏覽器是無法理解 TypeScript 程式碼的，必須要先將檔案轉成 JavaScript 瀏覽器才能使用。那要如何才能讓 TypeScript 知道哪些檔案是需要編譯的呢？這時候設定 tsconfig.json 就很重要了 (請參考上方 tsconfig.json 所新增的設定)。\n如果已經有設定指定的資料夾，就可以使用下列指令來將 .ts 檔案轉為 .js：\ntsc 轉換完成後就可以運行伺服器了：\nnode dist/app.js 畫面上會顯示 [server]: Server is running at http://localhost:3000 連接到後面的網址，就可以看到伺服器正常運行的畫面了。\n按下 Ctrl+c 就可以停止伺服器\n持續監看 TypeScript 檔案 在開發期間，通常會頻繁的改變網頁內容並觀察其結果，如果以上述方式每一次都要先編譯再執行，肯定會造成許多不方便，而且隨著時間增長程式也會越來越大，所編譯的時間也會相對增加。\n可以使用 nodemon 來解決這個問題。nodemon 是一個幫助開發者的工具，當目錄裡的檔案改變時，它會自動偵測並幫助我們重開應用程式。但是重開應用程式是不夠的，因為 TypeScript 還有要先編譯的問題，所以可以搭配 ts-node 一起使用 (如果沒有安裝此套件，在執行 nodemon 時就會要你安裝)。\n安裝兩個所需要的套件：\nnpm i -D nodemon ts-node 打開 package.json 來編寫腳本：\n\u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;tsc\u0026#34;, \u0026#34;dev\u0026#34;: \u0026#34;NODE_ENV=development nodemon ./src/app.ts\u0026#34; } 運行腳本：\nnpm run dev 你可以嘗試改變 res.send('Express + TypeScript Server'); 裡的文字，儲存後重整網頁就能看到改變的結果，就不需要進行編譯再執行的動作了。\n結論 以上就是建立一個最基本 Express + TypeScript 的方式。\n","permalink":"https://et860525.github.io/posts/typescript-express-initialization/","summary":"\u003cp\u003e這篇文章會紀錄如何在 \u003ca href=\"https://expressjs.com/\"\u003eExpress\u003c/a\u003e 專案裡設定 \u003ca href=\"https://www.typescriptlang.org/\"\u003eTypeScript\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e先決條件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e安裝 \u003ca href=\"https://nodejs.org/en/\"\u003eNode.js\u003c/a\u003e ( LTS ) 在你的開發環境上\u003c/li\u003e\n\u003cli\u003e基本的 \u003ccode\u003eNode.js\u003c/code\u003e 、 \u003ccode\u003eExpress\u003c/code\u003e 與 \u003ccode\u003eTypeScript\u003c/code\u003e 知識\u003c/li\u003e\n\u003c/ul\u003e","title":"TypeScript: 初始化 Express 專案"},{"content":"特徵( trait )，是定義特定型別與其他型別共享的功能。可以使用特徵界限 ( trait bounds ) 來指定泛型型別為擁有特定行為的任意型別。\n特徵類似於其他語言常稱作介面 ( interfaces ) 的功能，但還是有些差異。\n定義特徵 舉例，現在我們有兩個結構體各自擁有不同種類與不同數量的文字：\nNewsArticle 儲存特定地點的新聞故事 Tweet 則有最多 280 字元的內容，且有個欄位來判斷是全新的推文、轉推或其他推文的回覆。 我們想要建立一個多媒體資料庫，來顯示可能存在於 NewsArticle 或 Tweet 實例的總結 ( summary )。要達成這個目的，我們會呼叫該實例的 summarize 方法來獲得實例裡的 summary。\n新建立一個檔案為 src/lib.rs，並在此使用 trait 關鍵字定義一個 Summary 特徵：\npub trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String; } fn summarize(\u0026amp;self) -\u0026gt; String 宣告方法簽名來描述有實作此特徵的型別行為 特徵本體中可以有多個方法，每行會有一個方法簽名並都以分號做結尾。\n每個有實作此特徵的型別，都必須提供其自訂行為的方法本體。編譯器會強制要求任何有 Summary 特徵的型別都要有定義相同簽名的 summarize 方法。\n型別實作特徵 在 src/lib.rs 中定義 Summary 特徵完成後，就可以在資料庫裡實作它：\npub trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String; } pub struct NewsArticle { pub headline: String, pub location: String, pub author: String, pub content: String, } impl Summary for NewsArticle { fn summarize(\u0026amp;self) -\u0026gt; String { format!(\u0026#34;{} {} 著 ({})\u0026#34;, self.headline, self.author, self.location) } } pub struct Tweet { pub username: String, pub content: String, pub reply: bool, pub retweet: bool, } impl Summary for Tweet { fn summarize(\u0026amp;self) -\u0026gt; String { format!(\u0026#34;{}: {}\u0026#34;, self.username, self.content) } } 在 impl 之後我們加上想要實作的特徵，然後使用 for 關鍵字加上想要實作的型別名稱。並在 impl 區塊裡定義特徵所指定的方法。\n這裡使用的 rust_aggregator 是一開始 cargo new \u0026lt;name\u0026gt; 的名字，我們已經在函式庫裡加入對 NewsArticle 和 Tweet 實作 Summary 特徵，如果是 crate 的使用者只要直接呼叫即可。唯一的不同就是，使用的特徵也必須加入到作用域中。\n以下是我的 rust_aggregator 函式庫的 main.rs：\nuse rust_aggregator::{self, Summary, Tweet}; fn main() { let tweet = Tweet { username: String::from(\u0026#34;horse_ebooks\u0026#34;), content: String::from( \u0026#34;of course, as you probably already know, people\u0026#34;, ), reply: false, retweet: false, }; println!(\u0026#34;1 則新推文：{}\u0026#34;, tweet.summarize()); } 此程式碼會印出：1 則新推文：horse_ebooks: of course, as you probably alreadyknow, people。\n預設實作 將特徵內的一些方法預先定義實作，就不用要求型別實作這些方法了。如果特定型別想要更改特徵內方法的實作，直接寫上方法就能覆蓋預設的實作。以下是定義預設實作：\npub trait Summary { fn summarize(\u0026amp;self) -\u0026gt; String { String::from(\u0026#34;(閱讀更多...)\u0026#34;) } } 當 summarize 方法此時有預設實作，就不會強制要求型別需要設定此方法：\nfn main() { let article = NewsArticle { headline: String::from(\u0026#34;Penguins win the Stanley Cup Championship!\u0026#34;), location: String::from(\u0026#34;Pittsburgh, PA, USA\u0026#34;), author: String::from(\u0026#34;Iceburgh\u0026#34;), content: String::from( \u0026#34;The Pittsburgh Penguins once again are the best \\ hockey team in the NHL.\u0026#34;, ), }; println!(\u0026#34;有新文章發佈！{}\u0026#34;, article.summarize()); } 如果 NewsArticle 沒有實作 summarize 方法，此程式碼就會印出 有新文章發佈！(閱讀更多...)。\n特徵作為參數 使用特徵來定義函式所接受的參數。在 Summary 特徵定義一個新的 notify 函式，它會使用自己的參數 item 來呼叫 summarize 方法，所以此參數的型別會預期有 Summary 特徵。\npub fn notify(item: \u0026amp;impl Summary) { println!(\u0026#34;頭條新聞！{}\u0026#34;, item.summarize()); } item 參數指定實際型別用的是 impl 關鍵字加上特徵名稱，表示此參數會接受任何有實作指定特徵的型別 ( NewsArticle 或 Tweet ) 。但如果用其他型別像是 String 或 i32 來呼叫此程式碼則會無法編譯，因為那些型別沒有實作 Summary。\n這能讓函式的參數只接受特定特徵的型別\n特徵界限語法 impl Trait 是一個更長格式的語法糖，而這個格式稱為特徵界限 ( trait bound )，它長得像：\npub fn notify\u0026lt;T: Summary\u0026gt;(item: \u0026amp;T) { println!(\u0026#34;頭條新聞！{}\u0026#34;, item.summarize()); } impl Trait 語法比較方便，且在簡單的案例中可以讓程式碼比較簡潔，而特徵界限適合其他複雜的案例。\n舉例參數是兩個實作 Summary 參數，使用 impl Trait：\npub fn notify(item1: \u0026amp;impl Summary, item2: \u0026amp;impl Summary) { 如果函式允許 item1 與 item2 是不同型別，就可使用 impl Trait。但如果兩個參數是同一型別，就要改成特徵界限 ( trait bound ) 的方式：\npub fn notify\u0026lt;T: Summary\u0026gt;(item1: \u0026amp;T, item2: \u0026amp;T) { 這樣 item1 與 item2 的型別就必須要相同了。\n使用「+」指定多個特徵界限 在上一章泛型有提到用兩個特徵的函式：\nfn largest\u0026lt;T: PartialOrd + Copy\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { 這兩個特徵分別為：\nPartialOrd 判斷邏輯 Copy 將變數指派給另一個變數 這個方法也一樣可以用在參數裡。假設 notify 中的 item 不只能呼叫 summarize 方法，還能顯示格式化訊息的話，也可以使用 +：\nimpl Trait pub fn notify(item: \u0026amp;(impl Summary + Display)) { 特徵界限 pub fn notify\u0026lt;T: Summary + Display\u0026gt;(item: \u0026amp;T) 使用「where」使特徵界限更清楚 如果今天每個泛型都有自己的特徵界限，會造成函式簽名難以閱讀：\nfn some_function\u0026lt;T: Display + Clone, U: Clone + Debug\u0026gt;(t: \u0026amp;T, u: \u0026amp;U) -\u0026gt; i32 { 使用 where 讓一切看起來不那麼複雜：\nfn some_function\u0026lt;T, U\u0026gt;(t: \u0026amp;T, u: \u0026amp;U) -\u0026gt; i32 where { T: Display + Clone, U: Clone + Debug, } 回傳有實作特徵的型別 在回傳型別的位置使用 impl Trait 語法，來回傳某個有實作特徵的型別：\nfn returns_summarizable() -\u0026gt; impl Summary { Tweet { username: String::from(\u0026#34;horse_ebooks\u0026#34;), content: String::from( \u0026#34;of course, as you probably already know, people\u0026#34;, ), reply: false, retweet: false, } } 但是如果使用 impl Trait 的話就只能回傳單一型別。舉例來說，雖然程式碼指定回傳的型別為 impl Summary，但是將程式碼寫成可能會回傳 NewsArticle 或 Tweet 就會無法執行：\nfn returns_summarizable(switch: bool) -\u0026gt; impl Summary { if switch { NewsArticle { headline: String::from( \u0026#34;Penguins win the Stanley Cup Championship!\u0026#34;, ), location: String::from(\u0026#34;Pittsburgh, PA, USA\u0026#34;), author: String::from(\u0026#34;Iceburgh\u0026#34;), content: String::from( \u0026#34;The Pittsburgh Penguins once again are the best \\ hockey team in the NHL.\u0026#34;, ), } } else { Tweet { username: String::from(\u0026#34;horse_ebooks\u0026#34;), content: String::from( \u0026#34;of course, as you probably already know, people\u0026#34;, ), reply: false, retweet: false, } } } 對於可能返回 NewsArticle 或 Tweet 的話是不被允許的，因為 impl Trait 語法會限制在編譯器中最終決定的型別。\n透過特徵界限來選擇性實作方法 在有使用泛型型別參數 impl 區塊中使用特徵界限，就可以有選擇性的實作特定型別的實作方法：\nuse std::fmt::Display; struct Pair\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Pair\u0026lt;T\u0026gt; { fn new(x: T, y: T) -\u0026gt; Self { Self { x, y } } } impl\u0026lt;T: Display + PartialOrd\u0026gt; Pair\u0026lt;T\u0026gt; { fn cmp_display(\u0026amp;self) { if self.x \u0026gt;= self.y { println!(\u0026#34;最大的是 x = {}\u0026#34;, self.x); } else { println!(\u0026#34;最大的是 y = {}\u0026#34;, self.y); } } } 簡單來說，第一個 impl\u0026lt;T\u0026gt; 因為它沒有任何特徵，所有型別的 Pair 都可以使用這個方法；第二個 impl 則有限定型別，如果型別的特徵是 \u0026lt;T: Display + PartialOrd\u0026gt; 那它就可以使用，如果沒有則無法使用這個方法。\n而這種滿足特徵界限的型別實作特徵，則稱之為全面實作 ( blanket implementations )，這被廣泛的使用在 Rust 標準函式中。舉個例子，標準函式庫會對任何有實作 Display 特徵的型別實作 ToString，以下是類似於標準函式庫中的 impl 區塊：\nimpl\u0026lt;T: Display\u0026gt; ToString for T { // --省略-- } 標準函式庫有此全面實作，這樣就能將整數與字元轉為 String：\nlet s1 = 3.to_string(); let s2 = \u0026#39;c\u0026#39;.to_string(); 結論 上述有提到 Trait與其他程式語言的 Interface 有些不同，其中最大的不同在於：Interface 主要是根據特定的 object 來設定接口的；Trait 則可以對現有的型別來實現實作：\ntrait Hash { fn hash(\u0026amp;self) -\u0026gt; u64; } impl Hash for bool { fn hash(\u0026amp;self) -\u0026gt; u64 { if *self { 0 } else { 1 } } } impl Hash for i64 { fn hash(\u0026amp;self) -\u0026gt; u64 { *self as u64 } } 在 Hash 的作用域內就可以使用 true.hash() 這樣的寫法。\n引用 特徵：定義共同行為 Traits: Defining Shared Behavior Abstraction without overhead: traits in Rust ","permalink":"https://et860525.github.io/posts/rust-trait/","summary":"\u003cp\u003e特徵( trait )，是定義特定型別與其他型別共享的功能。可以使用\u003cstrong\u003e特徵界限 ( trait bounds )\u003c/strong\u003e 來指定泛型型別為擁有特定行為的任意型別。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e特徵類似於其他語言常稱作\u003cstrong\u003e介面 ( interfaces )\u003c/strong\u003e 的功能，但還是有些差異。\u003c/p\u003e\n\u003c/blockquote\u003e","title":"Rust: 特徵( Trait )"},{"content":"泛型 ( generics )，實際型別或屬性的抽象表示。舉例來說，String 和 i32 這兩個不同型別的資料都可以被存到 Vec 結構體建立的實例中，不需要針對型別來做分別，只要使用 Vec\u0026lt;String\u0026gt; 或 Vec\u0026lt;i32\u0026gt;，這是因為 Vec 結構體使用了泛型。\n泛型就是 參數多型 ( parametric polymorphism )，在定義型別或函數的時候不去明確指定具體的型別，而是以參數的形式來傳入型別，這可以讓程式設計更為彈性。\n以下先來看泛型在各個地方中如何定義。\n函式中定義 用一個找出陣列最大元素值的程式來實作泛型，首先，先來看它原本的樣子：\nfn largest_i32(list: \u0026amp;[i32]) -\u0026gt; i32 { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn largest_char(list: \u0026amp;[char]) -\u0026gt; char { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let int_list = vec![34, 50, 25, 100, 65]; let result = largest_i32(\u0026amp;int_list); println!(\u0026#34;The largest integer number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest_char(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 兩個 largest_i32、largest_char，可以分別從 32位元的有號整數陣列切片、字元陣列切片中找出最大的元素並回傳出來。基本上函式裡面的程式碼都是相同的，只是因為我們要處理不同型別的資料所以寫了三次，如果要連 i8、i16、i64、u8、u16、u32、u64、f32 等型別的陣列切片都寫，那不就要再多寫8次，所以 Rust 提供泛型來解決這個問題，以下是改為泛型示範：\nfn largest\u0026lt;T\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let int_list = vec![34, 50, 25, 100, 65]; let result = largest(\u0026amp;int_list); println!(\u0026#34;The largest integer number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 在呼叫 largest\u0026lt;T\u0026gt; 函式時，編譯器會在編譯階段時自動判斷泛型的第一個參數型別，來決定 T 會是什麼型別。如果不想要讓編譯器自己判定，那就在呼叫函式時直接指定泛型的型別：\nfn largest\u0026lt;T\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { // 略... } fn main() { let int_list = vec![34, 50, 25, 100, 65]; let result = largest::\u0026lt;i32\u0026gt;(\u0026amp;int_list); println!(\u0026#34;The largest integer number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest::\u0026lt;char\u0026gt;(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 不管如何，上述程式碼執行都會出現錯誤。這是因為要將值進行大於小於的判定之類的邏輯判斷，該值就必須要有 PartialOrd 的特徵 ( trait ) 。綜上所知，泛型的 T 可以是任何型別，但它不一定會是 PartialOrd 特徵，所以程式碼才會編譯失敗。為了要讓編譯器確定 T 要有這個 PartialOrd 特徵，我們必須事先明確定義，就像定義一般函式參數的型別：\nfn largest\u0026lt;T: PartialOrd\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { // 加上 PartialOrd 特徵 let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { // 略... } 再編譯一次還是會有錯誤，這是因為第 2行有將陣列的元素指派給 largest 變數，這種 把變數指派給另一個變數就表示這個型別有 Copy 的特徵。所以還要再讓 T 知道該型別還會有 Copy 特徵：\nfn largest\u0026lt;T: PartialOrd + Copy\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { // 再加上 Copy 特徵 let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { // 略... } 這樣程式就可以執行了：\n❯ cargo run Compiling hello_cargo v0.1.0 (file:///projects//hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.23s Running `target/debug/hello_cargo` The largest integer number is 100 The largest char is y 結構體中定義 在結構體的名稱右邊加上 \u0026lt;\u0026gt; 語法來定義泛型：\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T } fn main() { let integer = Point { x: 5, y: 10 }; let float = Point { x: 1.0, y: 4.0 }; } 編譯器在編譯期間也會自動判斷泛型第一個接觸的值，來決定型別。因此 integer 的泛型為 i32；float 的泛型為 f64。\n另一個例子：\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T } fn main() { let wont_work = Point { x: 5, y: 4.0 }; } 以上程式就會發生錯誤，因為泛型第一個接觸的值是 5 也就是 i32 型別，此時 Point 的 x 與 y 的值都一定要是 i32，自然也就不能存取 4.0 這個 f64 的型別。\n要解決上面的問題，可以使用兩個泛型參數：\nstruct Point\u0026lt;T, U\u0026gt; { x: T, y: U } fn main() { let both_integer = Point { x: 5, y: 10 }; let both_float = Point { x: 1.0, y: 4.0 }; let integer_and_float = Point { x: 5, y: 4.0 }; } 枚舉中定義 像是 Option 枚舉 與 Result 枚舉：\nenum Option\u0026lt;T\u0026gt; { Some(T), None } enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E) } 方法中定義 impl 關鍵字右邊也可以加上 \u0026lt;\u0026gt; 來定義泛型要使用的參數：\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } fn main() { let p = Point { x: 5, y: 10 }; println!(\u0026#34;p.x = {}\u0026#34;, p.x()); } impl 也可以只針對的特定的型別，來實作關聯函式和方法：\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } impl Point\u0026lt;f64\u0026gt; { fn distance_from_origin(\u0026amp;self) -\u0026gt; f64 { (self.x.powi(2) + self.y.powi(2)).sqrt() } } impl Point\u0026lt;i32\u0026gt; { fn distance_from_origin(\u0026amp;self) -\u0026gt; f64 { ((self.x.pow(2) + self.y.pow(2)) as f64).sqrt() } } fn main() { let p = Point { x: 3.0, y: 4.0 }; println!(\u0026#34;distance = {}\u0026#34;, p.distance_from_origin()); let p = Point { x: 5, y: 12 }; println!(\u0026#34;distance = {}\u0026#34;, p.distance_from_origin()); } 使用泛型的程式碼效能 Rust 的泛型不會有任何額外的運算效能的耗損。\nRust 在編譯時對使用泛型的程式碼進行單態化 ( monomorphization ) 。單態化能讓泛型轉換成特定程式碼的過程，並在編譯時填入實際型別。簡單來說，它會根據填入的實際型別，自動產生相應的程式碼。\n以下示範標準函式庫的泛型枚舉 Option\u0026lt;T\u0026gt; 是如何做到的：\nlet integer = Some(5); let float = Some(5.0); Rust 在編譯上面的程式碼時，就會進行單態化。上面的型態分別是 i32 與 f64，而編譯器會自動產生 Option_i32 和 Option_f64 的結構體 ( 編譯器實際的名稱與這邊的不同 )：\nenum Option_i32 { Some(i32), None, } enum Option_f64 { Some(f64), None, } fn main() { let integer = Option_i32::Some(5); let float = Option_f64::Some(5.0); } 因此，使用泛型的時候，程式在執行階段完全不需要使用額外的運算資源去進行型別的檢查，因為這些工作都在編譯期間自動完成了。\n結論 在 TypeScript 裡也有泛型的機制，所以學習起來並不那麼吃力。泛型就是為了解決這種不同型別但是程式碼重複的情況，加上下個章節會提到的特徵 ( trait ) 來限定哪種型別能使用。\n引用 泛型資料型別 ","permalink":"https://et860525.github.io/posts/rust-generics/","summary":"\u003cp\u003e泛型 ( generics )，實際型別或屬性的抽象表示。舉例來說，\u003ccode\u003eString\u003c/code\u003e 和 \u003ccode\u003ei32\u003c/code\u003e 這兩個不同型別的資料都可以被存到 \u003ca href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html\"\u003eVec 結構體\u003c/a\u003e建立的實例中，不需要針對型別來做分別，只要使用 \u003ccode\u003eVec\u0026lt;String\u0026gt;\u003c/code\u003e 或 \u003ccode\u003eVec\u0026lt;i32\u0026gt;\u003c/code\u003e，這是因為 \u003ccode\u003eVec\u003c/code\u003e 結構體使用了泛型。\u003c/p\u003e\n\u003cp\u003e泛型就是 \u003cstrong\u003e參數多型 ( parametric polymorphism )\u003c/strong\u003e，在定義型別或函數的時候不去明確指定具體的型別，而是以參數的形式來傳入型別，這可以讓程式設計更為彈性。\u003c/p\u003e\n\u003cp\u003e以下先來看泛型在各個地方中如何定義。\u003c/p\u003e","title":"Rust: 泛型( Generics )"},{"content":"在一開始撰寫文章時，本來想以寫比較久的 TypeScript 來做部落格的開頭文章，但在過年前接觸到 Rust 這個程式語言，就順勢把最近學到的東西放上來。等到把在 TypeScript 遇到的問題整理一下再寫成一個系列放上來。\n所有權 ( ownership ) 是 Rust 用來 管理程式記憶體的一系列規則，讓 Rust 不需要垃圾回收 ( Garbage collection ) 就可以保障記憶體的安全。\n所有程式都需要在執行時管理它們使用記憶體的方式，這裡有常見的兩種：\n語言本身就有垃圾回收機制，在程式執行時不斷尋找不再使用的記憶體 開發者必須親自分配和釋放記憶體 而 Rust 選擇第三種方式：記憶體由所有權系統管理，編譯器會在編譯時加上一些規則檢查，如果有違規，程式就無法編譯。\n所有權的規則完全不會降低執行程式的速度\n堆疊 ( Stack ) 與堆積 ( Heap ) 堆疊與堆積都是提供程式碼在執行時能夠使用的記憶體部分，但組成的方式不一樣。\n堆疊 ( Stack ) 會按照順序依序排列它們，並以相反順序移除，這也稱之為 後進先出 ( last in, first out )。所有在堆疊上的資料都必須是已知的固定大小，在編譯期間屬於未知或可能變更大小的資料則必須儲存在於堆積。\n想像堆疊是盤子，當加入盤子時只能疊在最上方，想要拿走盤子也只能拿最上面的盤子，想從中間或最下面插入或拿走盤子都不行。\n堆積 ( Heap ) 相比堆疊就沒有組織，當資料放進堆積時，記憶體分配器 ( memory allocator )會找到一塊夠大的空位，並標記已占用，然後回傳一個指標 ( pointer ) 指向該位址。這一整個過程稱之為 堆積上分配 ( allocating on the heap ) 或簡稱為分配。也因為指標是固定的大小，它可以被存在堆疊上，當需要存取實際的資料時，就透過指標去獲得即可。\n資料在堆疊與堆積的比較：\n將資料推入堆疊會比堆積分配還快，因為分配器不用去尋找空位，其位置永遠在堆疊的最上方。堆積就需要比較多的步驟，分配器必須要先找到一個足夠的空位，並做紀錄為下一次分配做準備。\n獲得資料的時間也是堆疊最快，因為堆積必須要透過指標才能找到。如果處理器與記憶體間跳轉的時間越少，則速度就越快。\n理解所有權主要就是為了管理堆積。\n所有權規則 Rust 中每個數值都有個擁有者 ( owner )。 同時間只能有一個擁有者。 當擁有者離開作用域 ( scope ) 時，數值就會被丟棄。 作用域 ( scope ) fn main() { { // s 在此處無效，因為它還沒宣告 let s = \u0026#34;hello\u0026#34;; // s 在此開始視為有效 // 使用 s } // 此作用域結束， s 不再有效 } 兩個重要的時間點：\n當 s 進入作用域時，它是有效的。 它持續被視為有效直到它離開作用域為止。 記憶體與分配 而對於 String 型別來說，為了要能夠支援可變性 (改變文字長度大小)，我們需要在堆積 ( Heap ) 上分配一塊編譯時未知大小的記憶體來儲存這樣的內容：\n記憶體分配器必須在執行時請求記憶體 我們不再需要這個 String 時，我們需要以某種方法將此記憶體還給分配器 第一部分，當呼叫 String::from ，他會請求分配一塊它需要的記憶體，這在其他程式語言都一樣。\n第二部分，在擁有垃圾回收機制(garbage collector, GC) 的語言中，GC 會追蹤並清理不再使用的記憶體。沒有 GC 的話，就必須自己去識別哪些記憶體不再使用，並且釋放它們。如果忘記釋放會造成記憶體的浪費，太早釋放則會拿到無效的變數，如果釋放了兩次，就會造成程式錯誤。\nRust 的方法是，當記憶體在擁有它的變數離開作用域時就會自動釋放：\nfn main() { { let s = String::from(\u0026#34;hello\u0026#34;); // s 在此開始視為有效 // 使用 s } // 此作用域結束 // s 不再有效 } 當 s 離開作用域，String 所需要的記憶體釋放回分配器。當離開作用域，Rust 會幫我們呼叫一個特殊函式 drop 來釋放記憶體。\n變數與資料互動的方式：移動（Move） fn main() { let x = 5; let y = x; } 一般來說，x 取得數值 5，然後 copy 一份給 y。\n但在 String 的版本，就不只是拷貝那麼簡單\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); } 這就要先了解 String 的架構，一個 String 由三個部分組成：\n指向儲存字串內容記憶體的指標 它的長度：是 String 內容在記憶體以位元組為單位所佔用的大小 它的容量：是 String 從分配器以位元組為單位取得的總記憶體量 所以將 s1 賦值給 s2，String 的資料會被拷貝，不過這裡指的是拷貝堆疊上的指標、長度和容量。\n如果 Rust 直接拷貝堆積的資料，s2 = s1 的動作花費會變得非常昂貴，當堆積上的資料非常龐大時，是十分影響效能的。\n先前有提到當變數離開作用域時，Rust 會自動呼叫 drop 函式來清理堆積上的資料。而當 s2 與 s1 離開作用域時，它們都會嘗試釋放相同的記憶體，這被稱為 雙重釋放 ( double free )，釋放記憶體兩次可能會導致記憶體損壞，進而造成安全漏洞。\n所以為了保障記憶體安全，let s2 = s1; 後 s1 就不再有效，所以在 s2 建立後再使用 s1 就會無法執行：\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); Rust 會跳出錯誤防止你執行：\n$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0382]: borrow of moved value: `s1` --\u0026gt; src/main.rs:5:28 | 2 | let s1 = String::from(\u0026#34;hello\u0026#34;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 3 | let s2 = s1; | -- value moved here 4 | 5 | println!(\u0026#34;{}, world!\u0026#34;, s1); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info) For more information about this error, try `rustc --explain E0382`. error: could not compile `ownership` due to previous error 變數與資料互動的方式：克隆（Clone） 如果需要深拷貝 ( deep copy )的話，使用 clone：\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {}, s2 = {}\u0026#34;, s1, s2); } 這樣 s1 與 s2 都能使用。\n只在堆疊上的資料：拷貝（Copy） fn main() { let x = 5; let y = x; println!(\u0026#34;x = {}, y = {}\u0026#34;, x, y); } Q: 那為什麼上面的程式碼會成立？沒有呼叫 clone，但 x 卻仍是有效的，沒有移動到 y。\nA: 因為像整數這樣的型別在編譯時是已知大小，所以只會存在在堆疊上。\nRust 有個特別的標記叫做 Copy 特徵（trait）可以用在標記像整數這樣存在堆疊上的型別。如果一個型別有實作 ( implement ) Drop 特徵的話，Rust 不會允許我們讓此型別擁有 Copy 特徵。\n哪些型別有實作 Copy 特徵呢？基本原則是任何簡單地純量數值都可以實作 Copy\n所有整數型別像是 u32。 布林型別 bool，它只有數值 true 與 false。 所有浮點數型別像是 f64。 字元型別 char。 元組，不過包含的型別也都要有實作 Copy 才行。比如 (i32, i32) 就有實作 Copy，但 (i32, String) 則無。 所有權與函式 傳遞數值給函式的方式和賦值給變數是類似的。\nfn main() { let s = String::from(\u0026#34;hello\u0026#34;); // s 進入作用域 takes_ownership(s); // s 的值進入函式 // 所以 s 也在此無效 let x = 5; // x 進入作用域 makes_copy(x); // x 本該移動進函式裡 // 但 i32 有 Copy，所以 x 可繼續使用 } fn takes_ownership(some_string: String) { // some_string 進入作用域 println!(\u0026#34;{}\u0026#34;, some_string); } // some_string 在此離開作用域並呼叫 `drop` // 佔用的記憶體被釋放 fn makes_copy(some_integer: i32) { // some_integer 進入作用域 println!(\u0026#34;{}\u0026#34;, some_integer); } // some_integer 在此離開作用域，沒有任何動作發生 如果呼叫 takes_ownership 後使用 s，Rust 會拋出編譯時期錯誤。\n回傳值與作用域 變數的所有權每次都會遵照相同的模式，只要賦值給其他變數就會移動。當有堆積的變數離開作用域，該值就會被 drop 清除，除非資料的所有權被轉移到其他變數。\n使用以下方法來回傳參數的所有值：\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let (s2, len) = calculate_length(s1); // s1 移入 calculate_length // 將所有權透過回傳給 s2 println!(\u0026#34;\u0026#39;{}\u0026#39; 的長度為 {}。\u0026#34;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() 回傳 String 的長度 (s, length) } 以上是正確的做法，但如果要重複使用這個值，每一次都要傳進傳出就很麻煩。所以 Rust 還有提供一個在不移轉所有權的情況下使用數值，稱為 引用 ( references )。\n引用與借用 引用 ( references ) 就像是指向某個地址的指標，我們可以追蹤存取到該處儲存的資訊，而讓該地址被其他變數所擁有，與指標不同的是，引用保證所指向的特定型別的數值一定是有效的。\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let len = calculate_length(\u0026amp;s1); println!(\u0026#34;\u0026#39;{}\u0026#39; 的長度為 {}。\u0026#34;, s1, len); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { s.len() } \u0026amp;s1 語法讓我們可以建立一個指向 s1 數值的引用，但不會擁有它。也因為它沒有所有權，它所指向的資料在引用不再使用後並不會被丟棄。\n建立引用這樣的動作叫做借用（borrowing）。就像現實世界一樣，如果有人擁有一個東西，他可以借用給你。當你使用完後，你就還給他，你並不擁有它。\n以下程式碼能不能執行？\nfn main() { let s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;s); } fn change(some_string: \u0026amp;String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 答案是不行，因為它只是借用，所以不能改變引用的值。\n可變引用 如果要讓上方的程式碼，改變引用的值：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 先將 s 加入 mut 讓他能被改變 change 函式的地方建立了一個可變引用 \u0026amp;mut s change 函式的新簽章為 some_string: \u0026amp;mut String 來接收這個可變引用 可變引用有一個大限制：對相同的變數可變引用只能有一個。如果嘗試建立兩個可變引用就會失敗：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}, {}\u0026#34;, r1, r2); } 錯誤資訊：\n$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0499]: cannot borrow `s` as mutable more than once at a time --\u0026gt; src/main.rs:5:14 | 4 | let r1 = \u0026amp;mut s; | ------ first mutable borrow occurs here 5 | let r2 = \u0026amp;mut s; | ^^^^^^ second mutable borrow occurs here 6 | 7 | println!(\u0026#34;{}, {}\u0026#34;, r1, r2); | -- first borrow later used here For more information about this error, try `rustc --explain E0499`. error: could not compile `ownership` due to previous error 這項限制的好處是 Rust 可以在編譯時期就防止資料競爭 ( data races )。它會由以下三種行為引發：\n同時有兩個以上的指標存取同個資料。 至少有一個指標在寫入資料。 沒有針對資料的同步存取機制。 資料競爭會造成未定義行為 ( undefined behavior )，而且在執行時你通常是很難診斷並修正的，而 Rust 能阻止這樣的問題，它不會讓有資料競爭的程式碼編譯。\n簡單來說，不要同時擁有同一個引用就可執行：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); { let r1 = \u0026amp;mut s; } // r1 離開作用域，所以建立新的引用也不會有問題 let r2 = \u0026amp;mut s; } 可變引用和不可變引用，不能同時使用：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;s; // 沒問題 let r2 = \u0026amp;s; // 沒問題 let r3 = \u0026amp;mut s; // 有問題！ println!(\u0026#34;{}, {}, and {}\u0026#34;, r1, r2, r3); } 這是因為，不可變引用的使用者不希望有人改變了值，並造成錯誤。不過多個不可變引用是沒問題的，因為大家都不能變更值。\n引用的作用域始於它被宣告的地方，一直到它最後一次引用被使用為止：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;s; // 沒問題 let r2 = \u0026amp;s; // 沒問題 println!(\u0026#34;{} and {}\u0026#34;, r1, r2); // 變數 r1 和 r2 將不再使用 let r3 = \u0026amp;mut s; // 沒問題 println!(\u0026#34;{}\u0026#34;, r3); } 迷途引用 ( Dangling references ) 有指標的程式語言，就會不小心產生 迷途指標 ( dangling pointer )。當資源已經被釋放但指標卻還留著，這樣的指標指向的地方很可能就已經被別人所有了。在 Rust 中編譯器會保證引用絕不會是迷途引用。\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { // 回傳 String 的迷途引用 let s = String::from(\u0026#34;hello\u0026#34;); // s 是個新 String \u0026amp;s // 我們回傳 String s 的引用 } // s 在此會離開作用域並釋放，它的記憶體就不見了。 // 危險！ s 是在 dangle 裡面產生的，當 dangle 結束 s 會被釋放。如果嘗試回傳 s，這個引用會指向一個無效的 String，所以 Rust 不會讓它發生。\n讓他回傳的值不是引用就可以了，這邊直接回傳 String就好：\nfn main() { let string = no_dangle(); } fn no_dangle() -\u0026gt; String { let s = String::from(\u0026#34;hello\u0026#34;); s } 切片 (Slice) 切片 (Slice) 可以引用一串集合的元素列，並非引用整個集合。切片也是一種引用，所以它沒有所有權。\n寫一個函式接收一串用空格分開單字的字串，如：Hello world、Good job，並回傳第一個找到的單字；如果沒有找到任何空格，就代表整個字串就是一個單字，並回傳整個字串。\nfn first_word(s: \u0026amp;String) -\u0026gt; usize { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return i; } } s.len() } fn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); // word 取得數值 5 s.clear(); // 這會清空 String，這就等於 \u0026#34;\u0026#34; // word 仍然是數值 5 ，但是我們已經沒有相等意義的字串了 // 擁有 5 的變數 word 現在完全沒意義！ } let bytes = s.as_bytes();：將 String 轉換成一個位元組陣列 for (i, \u0026amp;item) in bytes.iter().enumerate()：使用 iter 方法對位元建立一個疊代器 (iterator) iter()：是一個回傳集合中的每個元素方法 enumerate()：回傳的元組中第一個是索引(i)，第二個是元素的引用(\u0026amp;item) if item == b' ' {return i} ：找到空格後回傳該位置，如果沒有就回傳整個字串長度 程式雖然可以成功編譯，可以看到 s 的內容與 word 是沒有直接關係的，所以當 s 改變後，直接使用 word 去獲得 s 的單字，就會造成錯誤，這也導致需要留意 word 是不是與 s 脫鉤，而這個麻煩可以使用 Rust 的 字串切片(tring slice)。\n字串切片 fn main() { let s = String::from(\u0026#34;hello world\u0026#34;); let hello = \u0026amp;s[0..5]; let world = \u0026amp;s[6..11]; } 基本上就是 Python 的 slice，只是用引用的方式\n與其引用整個 String，透過 [0..5] 來引用了一部分的 String。\n更改上方回傳字串的程式：\nfn first_word(s: \u0026amp;str) -\u0026gt; \u0026amp;str { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return \u0026amp;s[0..i]; } } \u0026amp;s[..] } 可以將 fn first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;String 寫成 fn first_word(s: \u0026amp;str) -\u0026gt; \u0026amp;str\n現在編譯器會確保 String 的引用是有效的，所以當使用以下程式碼進行編譯，就會直接跳出錯誤：\nfn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); // word 取得數值 5 s.clear(); // 錯誤 println!(\u0026#34;第一個單字為：{}\u0026#34;, word); } $ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --\u0026gt; src/main.rs:18:5 | 16 | let word = first_word(\u0026amp;s); | -- immutable borrow occurs here 17 | 18 | s.clear(); // 錯誤！ | ^^^^^^^^^ mutable borrow occurs here 19 | 20 | println!(\u0026#34;第一個單字為：{}\u0026#34;, word); | ---- immutable borrow later used here For more information about this error, try `rustc --explain E0502`. error: could not compile `ownership` due to previous error 出現錯誤是因為借用的規則：當呼叫 clear 會清除 String，這表示它必須是可變引用。在 clear 後呼叫 println! ，這時就會用到 word 的引用。Rust 不允許同時存在 clear 的可變引用與 word 的不可變引用，所以會編譯失敗。這就能讓這些錯誤在編譯期間就被發現，進而修改。\n結論 在高中時期有使用 Unity 製作過遊戲，當時所使用的就是 C# 程式語言，對於 GC 這個機制是不陌生的，而到了大學轉為寫網頁時，JavaScript 也有 GC 的機制來回收記憶體。第一次接觸 Rust 管理記憶體的方法，所有權的規則看似限制很多其實用起來很直覺，他可以預防很多問題，例如: 指標是空的、迷途指標等等。\n引用 理解所有權 ","permalink":"https://et860525.github.io/posts/rust-ownership/","summary":"\u003cp\u003e在一開始撰寫文章時，本來想以寫比較久的 TypeScript 來做部落格的開頭文章，但在過年前接觸到 Rust 這個程式語言，就順勢把最近學到的東西放上來。等到把在 TypeScript 遇到的問題整理一下再寫成一個系列放上來。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e所有權 ( ownership )\u003c/strong\u003e 是 Rust 用來 \u003cstrong\u003e管理程式記憶體的一系列規則\u003c/strong\u003e，讓 Rust 不需要\u003ca href=\"https://zh.wikipedia.org/zh-tw/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)\"\u003e垃圾回收 ( Garbage collection )\u003c/a\u003e 就可以保障記憶體的安全。\u003c/p\u003e","title":"Rust: 所有權( Ownership )"},{"content":"在初期建立部落格時，本來是想租一台虛擬主機，再把寫好的網頁丟上去，不過最後還是選擇使用 GitHub Pages。\nJekyll 是 Github 建議的靜態網站產生器，不過在查詢資料時發現由 Go 所建構的 Hugo，點進去網頁上面就寫著自己是「世界上最快的網站架設框架」，那不試試看怎麼行。\n安裝 Hugo Hugo 有兩種版本，標準版 (standard) 與擴充版 (extended)，官方推薦使用 擴充版。\n下載的方式是根據自己的作業系統來選擇，而我使用的是 Linux，其他的作業系統可以參考 Hugo Installation。\n對於 Linux 系統，最簡單的方式就是直接使用 Package managers 下載：\nsudo apt install hugo 但是用這個方式下載的通常都不是最新版本，所以 Hugo 還提供 Prebuilt binaries 的方式，下載前要先確定版本 (使用當下是 v0.109.0)：\ncd /tmp \u0026amp;\u0026amp; mkdir hugo-binary \u0026amp;\u0026amp; cd hugo-binary wget https://github.com/gohugoio/hugo/releases/download/v0.109.0/hugo_extended_0.109.0_linux-amd64.tar.gz tar -xvf hugo_extended_0.109.0_linux-amd64.tar.gz cd ../ \u0026amp;\u0026amp; rm -rf hugo-binary/ hugo version 最後如果有出現版本號就是成功安裝了。\n初始化網站 使用以下得指令來建立專案的目錄：\nhugo new site my_blog 進到資料夾裡找到 config.toml，這個是 Hugo 的設定檔。\n如果你不喜歡使用 config.toml，Hugo 有提供 config.yaml 或 config.json，在建立專案時使用 hugo new my_project -f \u0026lt;yaml or json\u0026gt;\n選擇主題 可以到 Hugo Themes 來選擇你想要的主題，我這裡使用 hugo-PaperMod：\ncd my_blog git init # 初始化 Git git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 接著將主題名稱加入 config.toml：\ntheme = \u0026#34;PaperMod\u0026#34; 通常下載的主題裡面都會有 exampleSite 或是將它獨立出來，都能在該主題的 Github 找到。exampleSite 裡都會有已經設定好的 config.toml 可以直接套用，也可以根據自己的需求來設定。\n可以將 exampleSite 的 content 裡的檔案都放進專案的 content 裡，這就是預設的文章，可以在運行網站時先預覽顯示的狀態\n運行網站 hugo server 如果沒有任何錯誤，就可以到 http://localhost:1313 來觀看網站。\n這個網站只運行在你的電腦上，要放到 GitHub Pages 上才能讓其他人看到\n部屬到 GitHub Pages 首先，先在 Github 建立新的專案，名字為 \u0026lt;your-account\u0026gt;.github.io。\n根據官方文件 Host on GitHub，使用 GitHub Action 來部屬網站，在根目錄下新增檔案 .github/workflows/gh-pages.yml，該檔案的程式碼為：\nname: github pages on: push: branches: - main # Set a branch that will trigger a deployment pull_request: jobs: deploy: runs-on: ubuntu-22.04 steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 完成後再把專案推上去：\ngit status git add . git commit -m \u0026#34;Init my hugo blog\u0026#34; git branch -M main git remote add origin git@github.com:\u0026lt;your-account\u0026gt;/\u0026lt;your-account\u0026gt;.github.io.git git push -u origin master 到該 repo 的 Actions 就會看到以下畫面：\n![[github-actions-build.png]]\n如果有出現錯誤，請到 Repo -\u0026gt; Settings -\u0026gt; Actions -\u0026gt; General 確認\nActions permissions 設定為 Allow all actions and reusable workflows Workflow permissions 設定為 Read and write permissions Actions 完成編譯後，設定 Github Pages 要使用的 branch：\n![[github-pages-branch-select.png]]\n最後再到 https://\u0026lt;your-account\u0026gt;.github.io/ 就能看到設定的頁面了。\n","permalink":"https://et860525.github.io/posts/hugo-with-github-pages/","summary":"\u003cp\u003e在初期建立部落格時，本來是想租一台虛擬主機，再把寫好的網頁丟上去，不過最後還是選擇使用 \u003ca href=\"https://pages.github.com/\"\u003eGitHub Pages\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003eJekyll 是 Github 建議的靜態網站產生器，不過在查詢資料時發現由 Go 所建構的 \u003ca href=\"https://gohugo.io/\"\u003eHugo\u003c/a\u003e，點進去網頁上面就寫著自己是「世界上最快的網站架設框架」，那不試試看怎麼行。\u003c/p\u003e","title":"將 Hugo 產生的靜態網站部屬在 GitHub Pages"}]