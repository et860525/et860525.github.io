[{"content":"泛型 ( generics )，實際型別或屬性的抽象表示。舉例來說，String 和 i32 這兩個不同型別的資料都可以被存到 Vec 結構體建立的實例中，不需要針對型別來做分別，只要在用 Vec\u0026lt;String\u0026gt; 或 Vec\u0026lt;i32\u0026gt;，因為 Vec 結構體使用了泛型。\n泛型就是 參數多型 ( parametric polymorphism )，在定義型別或函數的時候不去明確指定具體的型別，而以參數的形式來傳入型別，這可以讓程式設計更為彈性。\n以下先來看泛型在各個地方中如何定義。\n函式中定義 用一個找出陣列最大元素值的程式來實作泛型，首先先看它原本的樣子：\nfn largest_i32(list: \u0026amp;[i32]) -\u0026gt; i32 { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn largest_char(list: \u0026amp;[char]) -\u0026gt; char { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let int_list = vec![34, 50, 25, 100, 65]; let result = largest_i32(\u0026amp;int_list); println!(\u0026#34;The largest integer number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest_char(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 兩個 largest_i32、largest_char，可以分別從 32位元的有號整數陣列切片、字元陣列切片中找出最大的元素並回傳出來。基本上函式裡面的程式碼都是相同的，只是因為我們要處理不同型別的資料所以寫了三次，如果要連 i8、i16、i64、u8、u16、u32、u64、f32 等型別的陣列切片都寫，那不就要再多寫8次，所以 Rust 提供泛型來解決這個問題，以下是改為泛型示範：\nfn largest\u0026lt;T\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { let int_list = vec![34, 50, 25, 100, 65]; let result = largest(\u0026amp;int_list); println!(\u0026#34;The largest integer number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 在呼叫 largest\u0026lt;T\u0026gt; 函式時，編譯器會在編譯階段時自動判斷泛型的第一個參數型別，來決定 T 會是什麼型別。如果不要讓編譯器自己判定，那就在呼叫函式時直接指定泛型的型別：\nfn largest\u0026lt;T\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { // 略... } fn main() { let int_list = vec![34, 50, 25, 100, 65]; let result = largest::\u0026lt;i32\u0026gt;(\u0026amp;int_list); println!(\u0026#34;The largest integer number is {}\u0026#34;, result); let char_list = vec![\u0026#39;y\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;q\u0026#39;]; let result = largest::\u0026lt;char\u0026gt;(\u0026amp;char_list); println!(\u0026#34;The largest char is {}\u0026#34;, result); } 不管如何，上述程式碼執行都會出現錯誤。這是因為要將值進行大於小於的判定之類的邏輯判斷，該值就必須要有 PartialOrd 的特徵 ( trait ) 。綜上所知，泛型的 T 可以是任何型別，但它不一定會是 PartialOrd 特徵，所以程式碼才會編譯失敗。為了要讓編譯器確定 T 要有這個 PartialOrd 特徵，我們必須事先明確定義，就像定義一般函式參數的型別：\nfn largest\u0026lt;T: PartialOrd\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { // 加上 PartialOrd 特徵 let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { // 略... } 再編譯一次還是會有錯誤，因為第 2行有將陣列的元素指派給 largest 變數，這種 把變數指派給另一個變數就表示這個型別有 Copy 的特徵。所以還要再讓 T 知道該型別還會有 Copy 特徵：\nfn largest\u0026lt;T: PartialOrd + Copy\u0026gt;(list: \u0026amp;[T]) -\u0026gt; T { // 再加上 Copy 特徵 let mut largest = list[0]; for \u0026amp;item in list.iter() { if item \u0026gt; largest { largest = item; } } largest } fn main() { // 略... } 這樣程式就可以執行了：\n❯ cargo run Compiling hello_cargo v0.1.0 (file:///projects//hello_cargo) Finished dev [unoptimized + debuginfo] target(s) in 0.23s Running `target/debug/hello_cargo` The largest integer number is 100 The largest char is y 結構體中定義 在結構體的名稱右邊加上 \u0026lt;\u0026gt; 語法來定義泛型：\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T } fn main() { let integer = Point { x: 5, y: 10 }; let float = Point { x: 1.0, y: 4.0 }; } 編譯器在編譯期間也會自動判斷泛型第一個接觸的值，來決定型別。因此 integer 的泛型為 i32；float 的泛型為 f64。\n另一個例子：\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T } fn main() { let wont_work = Point { x: 5, y: 4.0 }; } 以上程式就會發生錯誤，因為泛型第一個接觸的值是 5 也就是 i32 型別，此時 Point 的 x 與 y 的值都一定要是 i32，自然也就不能存取 4.0 這個 f64 的型別。\n要解決上面的問題，可以使用兩個泛型參數：\nstruct Point\u0026lt;T, U\u0026gt; { x: T, y: U } fn main() { let both_integer = Point { x: 5, y: 10 }; let both_float = Point { x: 1.0, y: 4.0 }; let integer_and_float = Point { x: 5, y: 4.0 }; } 枚舉中定義 像是 Option 枚舉 與 Result 枚舉：\nenum Option\u0026lt;T\u0026gt; { Some(T), None } enum Result\u0026lt;T, E\u0026gt; { Ok(T), Err(E) } 方法中定義 impl 關鍵字右邊也可以加上 \u0026lt;\u0026gt; 來定義泛型要使用的參數：\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } fn main() { let p = Point { x: 5, y: 10 }; println!(\u0026#34;p.x = {}\u0026#34;, p.x()); } impl 也可以只針對的特定的型別，來實作關聯函式和方法：\nstruct Point\u0026lt;T\u0026gt; { x: T, y: T, } impl\u0026lt;T\u0026gt; Point\u0026lt;T\u0026gt; { fn x(\u0026amp;self) -\u0026gt; \u0026amp;T { \u0026amp;self.x } } impl Point\u0026lt;f64\u0026gt; { fn distance_from_origin(\u0026amp;self) -\u0026gt; f64 { (self.x.powi(2) + self.y.powi(2)).sqrt() } } impl Point\u0026lt;i32\u0026gt; { fn distance_from_origin(\u0026amp;self) -\u0026gt; f64 { ((self.x.pow(2) + self.y.pow(2)) as f64).sqrt() } } fn main() { let p = Point { x: 3.0, y: 4.0 }; println!(\u0026#34;distance = {}\u0026#34;, p.distance_from_origin()); let p = Point { x: 5, y: 12 }; println!(\u0026#34;distance = {}\u0026#34;, p.distance_from_origin()); } 使用泛型的程式碼效能 Rust 的泛型不會有任何額外的運算效能的耗損。\nRust 在編譯時對使用泛型的程式碼進行單態化 ( monomorphization ) 。單態化能讓泛型轉換成特定程式碼的過程，並在編譯時填入實際型別。簡單來說，它會根據填入的實際型別，自動產生相應的程式碼。\n以下示範標準函式庫的泛型枚舉 Option\u0026lt;T\u0026gt; 是如何做到的：\nlet integer = Some(5); let float = Some(5.0); Rust 在編譯上面的程式碼時，就會進行單態化。上面的型態分別是 i32 與 f64，而編譯器會自動產生 Option_i32 和 Option_f64 的結構體 ( 編譯器實際的名稱與這邊的不同 )：\nenum Option_i32 { Some(i32), None, } enum Option_f64 { Some(f64), None, } fn main() { let integer = Option_i32::Some(5); let float = Option_f64::Some(5.0); } 因此，使用泛型的時候，程式在執行階段完全不需要使用額外的運算資源去進行型別的檢查，因為這些工作都在編譯期間自動完成了。\n結論 在 TypeScript 裡也有泛型的機制，所以學習起來並不那麼吃力。泛型就是為了解決這種不同型別但是程式碼重複的情況，加上下個章節會提到的特徵 ( trait ) 來限定哪種型別能使用。\n引用 泛型資料型別 ","permalink":"https://et860525.github.io/posts/rust-generics/","summary":"\u003cp\u003e泛型 ( generics )，實際型別或屬性的抽象表示。舉例來說，\u003ccode\u003eString\u003c/code\u003e 和 \u003ccode\u003ei32\u003c/code\u003e 這兩個不同型別的資料都可以被存到 \u003ca href=\"https://doc.rust-lang.org/std/vec/struct.Vec.html\"\u003eVec 結構體\u003c/a\u003e建立的實例中，不需要針對型別來做分別，只要在用 \u003ccode\u003eVec\u0026lt;String\u0026gt;\u003c/code\u003e 或 \u003ccode\u003eVec\u0026lt;i32\u0026gt;\u003c/code\u003e，因為 \u003ccode\u003eVec\u003c/code\u003e 結構體使用了泛型。\u003c/p\u003e\n\u003cp\u003e泛型就是 \u003cstrong\u003e參數多型 ( parametric polymorphism )\u003c/strong\u003e，在定義型別或函數的時候不去明確指定具體的型別，而以參數的形式來傳入型別，這可以讓程式設計更為彈性。\u003c/p\u003e\n\u003cp\u003e以下先來看泛型在各個地方中如何定義。\u003c/p\u003e","title":"Rust: 泛型( generics )"},{"content":"在一開始撰寫文章時，本來想以寫比較久的 TypeScript 來做部落格的開頭文章，但在過年前接觸到 Rust 這個程式語言，就順勢把最近學到的東西放上來。等到把在 TypeScript 的問題整理一下再寫一成個系列放上來。\n所有權 ( ownership ) 是 Rust 用來 管理程式記憶體的一系列規則，讓 Rust 不需要垃圾回收 ( Garbage collection ) 就可以保障記憶體的安全。\n所有程式都需要在執行時管理它們使用記憶體的方式，這裡有常見的兩種：\n語言本身就有垃圾回收機制，在程式執行時不斷尋找不再使用的記憶體 開發者必須親自分配和釋放記憶體 而 Rust 選擇第三種方式：記憶體由所有權系統管理，編譯器會在編譯時加上一些規則檢查，如果有違規，程式就無法編譯。\n所有權的規則完全不會降低執行程式的速度\n堆疊 ( Stack ) 與堆積 ( Heap ) 堆疊與堆積都是提供程式碼在執行時能夠使用的記憶體部分，但組成的方式不一樣。\n堆疊 ( Stack ) 會按照順序依序排列它們，並以相反順序移除，這也稱之為 後進先出 ( last in, first out )。所有在堆疊上的資料都必須是已知的固定大小，在編譯期間屬於未知或可能變更大小的資料則必須儲存在於堆積。\n想像堆疊是盤子，當加入盤子時只能疊在最上方，想要拿走盤子也只能拿最上面的盤子，想從中間或最下面插入或拿走盤子都不行。\n堆積 ( Heap ) 相比堆疊就沒有組織，當資料放進堆積時，記憶體分配器 ( memory allocator )會找到一塊夠大的空位，並標記已占用，然後回傳一個指標 ( pointer ) 指向該位址。這一整個過程稱之為 堆積上分配 ( allocating on the heap ) 或簡稱為分配。也因為指標是固定的大小，它可以被存在堆疊上，當需要存取實際的資料時，就透過指標去獲得即可。\n資料在堆疊與堆積的比較：\n將資料推入堆疊會比堆積分配還快，因為分配器不用去尋找空位，其位置永遠在堆疊的最上方。堆積就需要比較多的步驟，分配器必須要先找到一個足夠的空位，並做紀錄為下一次分配做準備。\n獲得資料的時間也是堆疊最快，因為堆積必須要透過指標才能找到。如果處理器與記憶體間跳轉的時間越少，則速度就越快。\n理解所有權主要就是為了管理堆積\n所有權規則 Rust 中每個數值都有個擁有者 ( owner )。 同時間只能有一個擁有者。 當擁有者離開作用域 ( scope ) 時，數值就會被丟棄。 作用域 ( scope ) fn main() { { // s 在此處無效，因為它還沒宣告 let s = \u0026#34;hello\u0026#34;; // s 在此開始視為有效 // 使用 s } // 此作用域結束， s 不再有效 } 兩個重要的時間點：\n當 s 進入作用域時，它是有效的。 它持續被視為有效直到它離開作用域為止。 記憶體與分配 而對於 String 型別來說，為了要能夠支援可變性 (改變文字長度大小)，我們需要在堆積 ( Heap ) 上分配一塊編譯時未知大小的記憶體來儲存這樣的內容：\n記憶體分配器必須在執行時請求記憶體 我們不再需要這個 String 時，我們需要以某種方法將此記憶體還給分配器 第一部分，當呼叫 String::from ，他會請求分配一塊它需要的記憶體，這在其他程式語言都一樣。\n第二部分，在擁有垃圾回收機制(garbage collector, GC) 的語言中，GC 會追蹤並清理不再使用的記憶體。沒有 GC 的話，就必須自己去識別哪些記憶體不再使用，並且釋放它們。如果忘記釋放會造成記憶體的浪費，太早釋放則會拿到無效的變數，如果釋放了兩次，就會造成程式錯誤。\nRust 的方法是，當記憶體在擁有它的變數離開作用域時就會自動釋放：\nfn main() { { let s = String::from(\u0026#34;hello\u0026#34;); // s 在此開始視為有效 // 使用 s } // 此作用域結束 // s 不再有效 } 當 s 離開作用域，String 所需要的記憶體釋放回分配器。當離開作用域，Rust 會幫我們呼叫一個特殊函式 drop 來釋放記憶體。\n變數與資料互動的方式：移動（Move） fn main() { let x = 5; let y = x; } 一般來說，x 取得數值 5，然後 copy 一份給 y。\n但在 String 的版本，就不只是拷貝那麼簡單\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); } 這就要先了解 String 的架構，一個 String 由三個部分組成：\n指向儲存字串內容記憶體的指標 它的長度：是 String 內容在記憶體以位元組為單位所佔用的大小 它的容量：是 String 從分配器以位元組為單位取得的總記憶體量 所以將 s1 賦值給 s2，String 的資料會被拷貝，不過這裡指的是拷貝堆疊上的指標、長度和容量。\n如果 Rust 直接拷貝堆積的資料，s2 = s1 的動作花費會變得非常昂貴，當堆積上的資料非常龐大時，是十分影響效能的。\n先前有提到當變數離開作用域時，Rust 會自動呼叫 drop 函式來清理堆積上的資料。而當 s2 與 s1 離開作用域時，它們都會嘗試釋放相同的記憶體，這被稱為 雙重釋放 ( double free )，釋放記憶體兩次可能會導致記憶體損壞，進而造成安全漏洞。\n所以為了保障記憶體安全，let s2 = s1; 後 s1 就不再有效，所以在 s2 建立後再使用 s1 就會無法執行：\nlet s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1; println!(\u0026#34;{}, world!\u0026#34;, s1); Rust 會跳出錯誤防止你執行：\n$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0382]: borrow of moved value: `s1` --\u0026gt; src/main.rs:5:28 | 2 | let s1 = String::from(\u0026#34;hello\u0026#34;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait 3 | let s2 = s1; | -- value moved here 4 | 5 | println!(\u0026#34;{}, world!\u0026#34;, s1); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info) For more information about this error, try `rustc --explain E0382`. error: could not compile `ownership` due to previous error 變數與資料互動的方式：克隆（Clone） 如果需要深拷貝 ( deep copy )的話，使用 clone：\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let s2 = s1.clone(); println!(\u0026#34;s1 = {}, s2 = {}\u0026#34;, s1, s2); } 這樣 s1 與 s2 都能使用。\n只在堆疊上的資料：拷貝（Copy） fn main() { let x = 5; let y = x; println!(\u0026#34;x = {}, y = {}\u0026#34;, x, y); } Q: 那為什麼上面的程式碼會成立？沒有呼叫 clone，但 x 卻仍是有效的，沒有移動到 y。\nA: 因為像整數這樣的型別在編譯時是已知大小，所以只會存在在堆疊上。\nRust 有個特別的標記叫做 Copy 特徵（trait）可以用在標記像整數這樣存在堆疊上的型別。如果一個型別有實作 ( implement ) Drop 特徵的話，Rust 不會允許我們讓此型別擁有 Copy 特徵。\n哪些型別有實作 Copy 特徵呢？基本原則是任何簡單地純量數值都可以實作 Copy\n所有整數型別像是 u32。 布林型別 bool，它只有數值 true 與 false。 所有浮點數型別像是 f64。 字元型別 char。 元組，不過包含的型別也都要有實作 Copy 才行。比如 (i32, i32) 就有實作 Copy，但 (i32, String) 則無。 所有權與函式 傳遞數值給函式的方式和賦值給變數是類似的。\nfn main() { let s = String::from(\u0026#34;hello\u0026#34;); // s 進入作用域 takes_ownership(s); // s 的值進入函式 // 所以 s 也在此無效 let x = 5; // x 進入作用域 makes_copy(x); // x 本該移動進函式裡 // 但 i32 有 Copy，所以 x 可繼續使用 } fn takes_ownership(some_string: String) { // some_string 進入作用域 println!(\u0026#34;{}\u0026#34;, some_string); } // some_string 在此離開作用域並呼叫 `drop` // 佔用的記憶體被釋放 fn makes_copy(some_integer: i32) { // some_integer 進入作用域 println!(\u0026#34;{}\u0026#34;, some_integer); } // some_integer 在此離開作用域，沒有任何動作發生 如果呼叫 takes_ownership 後使用 s，Rust 會拋出編譯時期錯誤。\n回傳值與作用域 變數的所有權每次都會遵照相同的模式，只要賦值給其他變數就會移動。當有堆積的變數離開作用域，該值就會被 drop 清除，除非資料的所有權被轉移到其他變數。\n使用以下方法來回傳參數的所有值：\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let (s2, len) = calculate_length(s1); // s1 移入 calculate_length // 將所有權透過回傳給 s2 println!(\u0026#34;\u0026#39;{}\u0026#39; 的長度為 {}。\u0026#34;, s2, len); } fn calculate_length(s: String) -\u0026gt; (String, usize) { let length = s.len(); // len() 回傳 String 的長度 (s, length) } 以上是正確的做法，但如果要重複使用這個值，每一次都要傳進傳出就很麻煩。所以 Rust 還有提供一個在不移轉所有權的情況下使用數值，稱為 引用 ( references )。\n引用與借用 引用 ( references ) 就像是指向某個地址的指標，我們可以追蹤存取到該處儲存的資訊，而讓該地址被其他變數所擁有，與指標不同的是，引用保證所指向的特定型別的數值一定是有效的。\nfn main() { let s1 = String::from(\u0026#34;hello\u0026#34;); let len = calculate_length(\u0026amp;s1); println!(\u0026#34;\u0026#39;{}\u0026#39; 的長度為 {}。\u0026#34;, s1, len); } fn calculate_length(s: \u0026amp;String) -\u0026gt; usize { s.len() } \u0026amp;s1 語法讓我們可以建立一個指向 s1 數值的引用，但不會擁有它。也因為它沒有所有權，它所指向的資料在引用不再使用後並不會被丟棄。\n建立引用這樣的動作叫做借用（borrowing）。就像現實世界一樣，如果有人擁有一個東西，他可以借用給你。當你使用完後，你就還給他，你並不擁有它。\n以下程式碼能不能執行？\nfn main() { let s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;s); } fn change(some_string: \u0026amp;String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 答案是不行，因為它只是借用，所以不能改變引用的值。\n可變引用 如果要讓上方的程式碼，改變引用的值：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); change(\u0026amp;mut s); } fn change(some_string: \u0026amp;mut String) { some_string.push_str(\u0026#34;, world\u0026#34;); } 先將 s 加入 mut 讓他能被改變 change 函式的地方建立了一個可變引用 \u0026amp;mut s change 函式的新簽章為 some_string: \u0026amp;mut String 來接收這個可變引用 可變引用有一個大限制：對相同的變數可變引用只能有一個。如果嘗試建立兩個可變引用就會失敗：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;mut s; let r2 = \u0026amp;mut s; println!(\u0026#34;{}, {}\u0026#34;, r1, r2); } 錯誤資訊：\n$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0499]: cannot borrow `s` as mutable more than once at a time --\u0026gt; src/main.rs:5:14 | 4 | let r1 = \u0026amp;mut s; | ------ first mutable borrow occurs here 5 | let r2 = \u0026amp;mut s; | ^^^^^^ second mutable borrow occurs here 6 | 7 | println!(\u0026#34;{}, {}\u0026#34;, r1, r2); | -- first borrow later used here For more information about this error, try `rustc --explain E0499`. error: could not compile `ownership` due to previous error 這項限制的好處是 Rust 可以在編譯時期就防止資料競爭 ( data races )。它會由以下三種行為引發：\n同時有兩個以上的指標存取同個資料。 至少有一個指標在寫入資料。 沒有針對資料的同步存取機制。 資料競爭會造成未定義行為 ( undefined behavior )，而且在執行時你通常是很難診斷並修正的，而 Rust 能阻止這樣的問題，它不會讓有資料競爭的程式碼編譯。\n簡單來說，不要同時擁有同一個引用就可執行：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); { let r1 = \u0026amp;mut s; } // r1 離開作用域，所以建立新的引用也不會有問題 let r2 = \u0026amp;mut s; } 可變引用和不可變引用，不能同時使用：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;s; // 沒問題 let r2 = \u0026amp;s; // 沒問題 let r3 = \u0026amp;mut s; // 有問題！ println!(\u0026#34;{}, {}, and {}\u0026#34;, r1, r2, r3); } 這是因為，不可變引用的使用者不希望有人改變了值，並造成錯誤。不過多個不可變引用是沒問題的，因為大家都不能變更值。\n引用的作用域始於它被宣告的地方，一直到它最後一次引用被使用為止：\nfn main() { let mut s = String::from(\u0026#34;hello\u0026#34;); let r1 = \u0026amp;s; // 沒問題 let r2 = \u0026amp;s; // 沒問題 println!(\u0026#34;{} and {}\u0026#34;, r1, r2); // 變數 r1 和 r2 將不再使用 let r3 = \u0026amp;mut s; // 沒問題 println!(\u0026#34;{}\u0026#34;, r3); } 迷途引用 ( Dangling pointer ) 有指標的程式語言，就會不小心產生 迷途指標 ( dangling pointer )。當資源已經被釋放但指標卻還留著，這樣的指標指向的地方很可能就已經被別人所有了。在 Rust 中編譯器會保證引用絕不會是迷途引用。\nfn main() { let reference_to_nothing = dangle(); } fn dangle() -\u0026gt; \u0026amp;String { // 回傳 String 的迷途引用 let s = String::from(\u0026#34;hello\u0026#34;); // s 是個新 String \u0026amp;s // 我們回傳 String s 的引用 } // s 在此會離開作用域並釋放，它的記憶體就不見了。 // 危險！ s 是在 dangle 裡面產生的，當 dangle 結束 s 會被釋放。如果嘗試回傳 s，這個引用會指向一個無效的 String，所以 Rust 不會讓它發生。\n讓他回傳的值不是引用就可以了，這邊直接回傳 String就好：\nfn main() { let string = no_dangle(); } fn no_dangle() -\u0026gt; String { let s = String::from(\u0026#34;hello\u0026#34;); s } 切片 (Slice) 切片 (Slice) 可以引用一串集合的元素列，並非引用整個集合。切片也是一種引用，所以它沒有所有權。\n寫一個函式接收一串用空格分開單字的字串，如：Hello world、Good job，並回傳第一個找到的單字；如果沒有找到任何空格，就代表整個字串就是一個單字，並回傳整個字串。\nfn first_word(s: \u0026amp;String) -\u0026gt; usize { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return i; } } s.len() } fn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); // word 取得數值 5 s.clear(); // 這會清空 String，這就等於 \u0026#34;\u0026#34; // word 仍然是數值 5 ，但是我們已經沒有相等意義的字串了 // 擁有 5 的變數 word 現在完全沒意義！ } let bytes = s.as_bytes();：將 String 轉換成一個位元組陣列 for (i, \u0026amp;item) in bytes.iter().enumerate()：使用 iter 方法對位元建立一個疊代器 (iterator) iter()：是一個回傳集合中的每個元素方法 enumerate()：回傳的元組中第一個是索引(i)，第二個是元素的引用(\u0026amp;item) if item == b' ' {return i} ：找到空格後回傳該位置，如果沒有就回傳整個字串長度 程式雖然可以成功編譯，可以看到 s 的內容與 word 是沒有直接關係的，所以當 s 改變後，直接使用 word 去獲得 s 的單字，就會造成錯誤，這也導致需要留意 word 是不是與 s 脫鉤，而這個麻煩可以使用 Rust 的 字串切片(tring slice)。\n字串切片 fn main() { let s = String::from(\u0026#34;hello world\u0026#34;); let hello = \u0026amp;s[0..5]; let world = \u0026amp;s[6..11]; } 基本上就是 Python 的 slice，只是用引用的方式\n與其引用整個 String，透過 [0..5] 來引用了一部分的 String。\n更改上方回傳字串的程式：\nfn first_word(s: \u0026amp;str) -\u0026gt; \u0026amp;str { let bytes = s.as_bytes(); for (i, \u0026amp;item) in bytes.iter().enumerate() { if item == b\u0026#39; \u0026#39; { return \u0026amp;s[0..i]; } } \u0026amp;s[..] } 可以將 fn first_word(s: \u0026amp;String) -\u0026gt; \u0026amp;String 寫成 fn first_word(s: \u0026amp;str) -\u0026gt; \u0026amp;str\n現在編譯器會確保 String 的引用是有效的，所以當使用以下程式碼進行編譯，就會直接跳出錯誤：\nfn main() { let mut s = String::from(\u0026#34;hello world\u0026#34;); let word = first_word(\u0026amp;s); // word 取得數值 5 s.clear(); // 錯誤 println!(\u0026#34;第一個單字為：{}\u0026#34;, word); } $ cargo run Compiling ownership v0.1.0 (file:///projects/ownership) error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable --\u0026gt; src/main.rs:18:5 | 16 | let word = first_word(\u0026amp;s); | -- immutable borrow occurs here 17 | 18 | s.clear(); // 錯誤！ | ^^^^^^^^^ mutable borrow occurs here 19 | 20 | println!(\u0026#34;第一個單字為：{}\u0026#34;, word); | ---- immutable borrow later used here For more information about this error, try `rustc --explain E0502`. error: could not compile `ownership` due to previous error 出現錯誤是因為借用的規則：當呼叫 clear 會清除 String，這表示它必須是可變引用。在 clear 後呼叫 println! ，這時就會用到 word 的引用。Rust 不允許同時存在 clear 的可變引用與 word 的不可變引用，所以會編譯失敗。這就能讓這些錯誤在編譯期間就被發現，進而修改。\n結論 在高中時期有使用 Unity 製作過遊戲，當時所使用的就是 C# 程式語言，對於 GC 這個機制是不陌生的，而到了大學轉為寫網頁時，JavaScript 也有 GC 的機制來回收記憶體。第一次接觸 Rust 管理記憶體的方法，所有權的規則看似限制很多其實用起來很直覺，他可以預防很多問題，例如: 指標是空的、迷途指標等等。\n引用 理解所有權 ","permalink":"https://et860525.github.io/posts/rust-ownership/","summary":"\u003cp\u003e在一開始撰寫文章時，本來想以寫比較久的 TypeScript 來做部落格的開頭文章，但在過年前接觸到 Rust 這個程式語言，就順勢把最近學到的東西放上來。等到把在 TypeScript 的問題整理一下再寫一成個系列放上來。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e所有權 ( ownership )\u003c/strong\u003e 是 Rust 用來 \u003cstrong\u003e管理程式記憶體的一系列規則\u003c/strong\u003e，讓 Rust 不需要\u003ca href=\"https://zh.wikipedia.org/zh-tw/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)\"\u003e垃圾回收 ( Garbage collection )\u003c/a\u003e 就可以保障記憶體的安全。\u003c/p\u003e","title":"Rust: 所有權( Ownership )"},{"content":"在初期建立部落格時，本來是想租一台虛擬主機，再把寫好的網頁丟上去，不過最後還是選擇使用 GitHub Pages。\nJekyll 是 Github 建議的靜態網站產生器，不過在查詢資料時發現由 Go 所建構的 Hugo，點進去網頁上面就寫著自己是「世界上最快的網站架設框架」，那不試試看怎麼行。\n安裝 Hugo Hugo 有兩種版本，標準版 (standard) 與擴充版 (extended)，官方推薦使用 擴充版。\n下載的方式是根據自己的作業系統來選擇，而我使用的是 Linux，其他的作業系統可以參考 Hugo Installation。\n對於 Linux 系統，最簡單的方式就是直接使用 Package managers 下載：\nsudo apt install hugo 但是用這個方式下載的通常都不是最新版本，所以 Hugo 還提供 Prebuilt binaries 的方式，下載前要先確定版本 (使用當下是 v0.109.0)：\ncd /tmp \u0026amp;\u0026amp; mkdir hugo-binary \u0026amp;\u0026amp; cd hugo-binary wget https://github.com/gohugoio/hugo/releases/download/v0.109.0/hugo_extended_0.109.0_linux-amd64.tar.gz tar -xvf hugo_extended_0.109.0_linux-amd64.tar.gz cd ../ \u0026amp;\u0026amp; rm -rf hugo-binary/ hugo version 最後如果有出現版本號就是成功安裝了。\n初始化網站 使用以下得指令來建立專案的目錄：\nhugo new site my_blog 進到資料夾裡找到 config.toml，這個是 Hugo 的設定檔。\n如果你不喜歡使用 config.toml，Hugo 有提供 config.yaml 或 config.json，在建立專案時使用 hugo new my_project -f \u0026lt;yaml or json\u0026gt;\n選擇主題 可以到 Hugo Themes 來選擇你想要的主題，我這裡使用 hugo-PaperMod：\ncd my_blog git init # 初始化 Git git submodule add --depth=1 https://github.com/adityatelange/hugo-PaperMod.git themes/PaperMod git submodule update --init --recursive # needed when you reclone your repo (submodules may not get cloned automatically) 接著將主題名稱加入 config.toml：\ntheme = \u0026#34;PaperMod\u0026#34; 通常下載的主題裡面都會有 exampleSite 或是將它獨立出來，都能在該主題的 Github 找到。exampleSite 裡都會有已經設定好的 config.toml 可以直接套用，也可以根據自己的需求來設定。\n可以將 exampleSite 的 content 裡的檔案都放進專案的 content 裡，這就是預設的文章，可以在運行網站時先預覽顯示的狀態\n運行網站 hugo server 如果沒有任何錯誤，就可以到 http://localhost:1313 來觀看網站。\n這個網站只運行在你的電腦上，要放到 GitHub Pages 上才能讓其他人看到\n部屬到 GitHub Pages 首先，先在 Github 建立新的專案，名字為 \u0026lt;your-account\u0026gt;.github.io。\n根據官方文件 Host on GitHub，使用 GitHub Action 來部屬網站，在根目錄下新增檔案 .github/workflows/gh-pages.yml，該檔案的程式碼為：\nname: github pages on: push: branches: - main # Set a branch that will trigger a deployment pull_request: jobs: deploy: runs-on: ubuntu-22.04 steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; # extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == \u0026#39;refs/heads/main\u0026#39; with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public 完成後再把專案推上去：\ngit status git add . git commit -m \u0026#34;Init my hugo blog\u0026#34; git branch -M main git remote add origin git@github.com:\u0026lt;your-account\u0026gt;/\u0026lt;your-account\u0026gt;.github.io.git git push -u origin master 到該 repo 的 Actions 就會看到以下畫面：\n![[github-actions-build.png]]\n如果有出現錯誤，請到 Repo -\u0026gt; Settings -\u0026gt; Actions -\u0026gt; General 確認\nActions permissions 設定為 Allow all actions and reusable workflows Workflow permissions 設定為 Read and write permissions Actions 完成編譯後，設定 Github Pages 要使用的 branch：\n![[github-pages-branch-select.png]]\n最後再到 https://\u0026lt;your-account\u0026gt;.github.io/ 就能看到設定的頁面了。\n","permalink":"https://et860525.github.io/posts/hugo-with-github-pages/","summary":"\u003cp\u003e在初期建立部落格時，本來是想租一台虛擬主機，再把寫好的網頁丟上去，不過最後還是選擇使用 \u003ca href=\"https://pages.github.com/\"\u003eGitHub Pages\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003eJekyll 是 Github 建議的靜態網站產生器，不過在查詢資料時發現由 Go 所建構的 \u003ca href=\"https://gohugo.io/\"\u003eHugo\u003c/a\u003e，點進去網頁上面就寫著自己是「世界上最快的網站架設框架」，那不試試看怎麼行。\u003c/p\u003e","title":"將 Hugo 產生的靜態網站部屬在 GitHub Pages"}]